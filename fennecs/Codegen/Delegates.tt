<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".generated.cs" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    const int maxArity = 5;

    string GenList(string prefix, int count, string separator = ", ", string suffix = "")
    {
        return string.Join(separator, 
            Enumerable.Range(0, count).Select(i => $"{prefix}{i}{suffix}"));
    }

    // Generate all permutations of modifiers (in/out/ref) for n components
    IEnumerable<string[]> GetModifierPermutations(int componentCount)
    {
        var modifiers = new[] { "in", "out", "ref" };
        return GetPermutationsRecursive(componentCount, modifiers);
    }

    // Generate Memory/ReadOnlyMemory permutations
    IEnumerable<string[]> GetMemoryPermutations(int componentCount)
    {
        var memoryTypes = new[] { "Memory", "ReadOnlyMemory" };
        return GetPermutationsRecursive(componentCount, memoryTypes);
    }

    IEnumerable<string[]> GetPermutationsRecursive(int depth, string[] options)
    {
        if (depth == 0)
        {
            yield return [];
            yield break;
        }

        foreach (var option in options)
        {
            foreach (var rest in GetPermutationsRecursive(depth - 1, options))
            {
                yield return new[] { option }.Concat(rest).ToArray();
            }
        }
    }

    string ModifierSignature(string[] modifiers, int n)
    {
        return string.Join(", ", Enumerable.Range(0, n)
            .Select(i => $"{modifiers[i]} C{i} comp{i}"));
    }

    string MemorySignature(string[] memoryTypes, int n)
    {
        return string.Join(", ", Enumerable.Range(0, n)
            .Select(i => $"{memoryTypes[i]}<C{i}> comp{i}"));
    }

    string ModifierKey(string[] modifiers)
    {
        return string.Join("", modifiers.Select(m => m.ToUpperInvariant()[0]));
    }

    string MemoryKey(string[] memoryTypes)
    {
        return string.Join("", memoryTypes.Select(m => m == "Memory" ? "M" : "R"));
    }

    bool IsAllRef(string[] modifiers)
    {
        return modifiers.All(m => m == "ref");
    }

    bool IsAllMemory(string[] memoryTypes)
    {
        return memoryTypes.All(m => m == "Memory");
    }
#>
//------------------------------------------------------------------------------
// <auto-generated>
//   This file is generated by Delegates.tt
//   Do not modify directly.
// </auto-generated>
//------------------------------------------------------------------------------

// Date: <#= DateTime.UtcNow #>

namespace fennecs;
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

// ============================================================================
// ComponentFilter - always uses 'in' modifier
// ============================================================================
public delegate bool ComponentFilter<C>(in C c);

<# for (var n = 1; n <= maxArity; n++) { #>
public delegate bool FilterDelegate<<#= GenList("C", n) #>>(<#= string.Join(", ", Enumerable.Range(0, n).Select(i => $"in C{i} c{i}")) #>);
<# } #>

// ============================================================================
// ComponentAction - base version (all ref)
// ============================================================================
<# for (var n = 1; n <= maxArity; n++) { #>
public delegate void ComponentAction<<#= GenList("C", n) #>>(<#= string.Join(", ", Enumerable.Range(0, n).Select(i => $"ref C{i} comp{i}")) #>);
<# } #>

// ============================================================================
// ComponentAction - modifier permutations
// ============================================================================
<# 
for (var n = 1; n <= maxArity; n++)
{
    var permutations = GetModifierPermutations(n).ToList();
    foreach (var mods in permutations)
    {
        if (IsAllRef(mods)) continue; // Skip, already defined above
        var modKey = ModifierKey(mods);
        var modSig = ModifierSignature(mods, n);
#>
/// <summary>ComponentAction with modifiers: <#= string.Join(", ", mods) #></summary>
public delegate void ComponentAction<#= modKey #><<#= GenList("C", n) #>>(<#= modSig #>);
<# 
    }
} 
#>

// ============================================================================
// UniformComponentAction - base version (all ref)
// ============================================================================
<# for (var n = 1; n <= maxArity; n++) { #>
public delegate void UniformComponentAction<in U, <#= GenList("C", n) #>>(U uniform, <#= string.Join(", ", Enumerable.Range(0, n).Select(i => $"ref C{i} comp{i}")) #>);
<# } #>

// ============================================================================
// UniformComponentAction - modifier permutations
// ============================================================================
<# 
for (var n = 1; n <= maxArity; n++)
{
    var permutations = GetModifierPermutations(n).ToList();
    foreach (var mods in permutations)
    {
        if (IsAllRef(mods)) continue;
        var modKey = ModifierKey(mods);
        var modSig = ModifierSignature(mods, n);
#>
/// <summary>UniformComponentAction with modifiers: <#= string.Join(", ", mods) #></summary>
public delegate void UniformComponentAction<#= modKey #><in U, <#= GenList("C", n) #>>(U uniform, <#= modSig #>);
<# 
    }
} 
#>

// ============================================================================
// EntityComponentAction - base version (all ref)
// ============================================================================
<# for (var n = 1; n <= maxArity; n++) { #>
public delegate void EntityComponentAction<<#= GenList("C", n) #>>(in Entity entity, <#= string.Join(", ", Enumerable.Range(0, n).Select(i => $"ref C{i} comp{i}")) #>);
<# } #>

// ============================================================================
// EntityComponentAction - modifier permutations
// ============================================================================
<# 
for (var n = 1; n <= maxArity; n++)
{
    var permutations = GetModifierPermutations(n).ToList();
    foreach (var mods in permutations)
    {
        if (IsAllRef(mods)) continue;
        var modKey = ModifierKey(mods);
        var modSig = ModifierSignature(mods, n);
#>
/// <summary>EntityComponentAction with modifiers: <#= string.Join(", ", mods) #></summary>
public delegate void EntityComponentAction<#= modKey #><<#= GenList("C", n) #>>(in Entity entity, <#= modSig #>);
<# 
    }
} 
#>

// ============================================================================
// UniformEntityComponentAction - base version (all ref)
// ============================================================================
<# for (var n = 1; n <= maxArity; n++) { #>
public delegate void UniformEntityComponentAction<in U, <#= GenList("C", n) #>>(U uniform, in Entity entity, <#= string.Join(", ", Enumerable.Range(0, n).Select(i => $"ref C{i} comp{i}")) #>);
<# } #>

// ============================================================================
// UniformEntityComponentAction - modifier permutations
// ============================================================================
<# 
for (var n = 1; n <= maxArity; n++)
{
    var permutations = GetModifierPermutations(n).ToList();
    foreach (var mods in permutations)
    {
        if (IsAllRef(mods)) continue;
        var modKey = ModifierKey(mods);
        var modSig = ModifierSignature(mods, n);
#>
/// <summary>UniformEntityComponentAction with modifiers: <#= string.Join(", ", mods) #></summary>
public delegate void UniformEntityComponentAction<#= modKey #><in U, <#= GenList("C", n) #>>(U uniform, in Entity entity, <#= modSig #>);
<# 
    }
} 
#>

// ============================================================================
// MemoryAction - base version (all Memory)
// ============================================================================
<# for (var n = 1; n <= maxArity; n++) { #>
public delegate void MemoryAction<<#= GenList("C", n) #>>(<#= string.Join(", ", Enumerable.Range(0, n).Select(i => $"Memory<C{i}> comp{i}")) #>);
<# } #>

// ============================================================================
// MemoryAction - Memory/ReadOnlyMemory permutations
// ============================================================================
<# 
for (var n = 1; n <= maxArity; n++)
{
    var permutations = GetMemoryPermutations(n).ToList();
    foreach (var memTypes in permutations)
    {
        if (IsAllMemory(memTypes)) continue; // Skip, already defined above
        var memKey = MemoryKey(memTypes);
        var memSig = MemorySignature(memTypes, n);
#>
/// <summary>MemoryAction with memory types: <#= string.Join(", ", memTypes) #></summary>
public delegate void MemoryAction<#= memKey #><<#= GenList("C", n) #>>(<#= memSig #>);
<# 
    }
} 
#>

// ============================================================================
// MemoryUniformAction - base version (all Memory)
// ============================================================================
<# for (var n = 1; n <= maxArity; n++) { #>
public delegate void MemoryUniformAction<in U, <#= GenList("C", n) #>>(U uniform, <#= string.Join(", ", Enumerable.Range(0, n).Select(i => $"Memory<C{i}> comp{i}")) #>);
<# } #>

// ============================================================================
// MemoryUniformAction - Memory/ReadOnlyMemory permutations
// ============================================================================
<# 
for (var n = 1; n <= maxArity; n++)
{
    var permutations = GetMemoryPermutations(n).ToList();
    foreach (var memTypes in permutations)
    {
        if (IsAllMemory(memTypes)) continue;
        var memKey = MemoryKey(memTypes);
        var memSig = MemorySignature(memTypes, n);
#>
/// <summary>MemoryUniformAction with memory types: <#= string.Join(", ", memTypes) #></summary>
public delegate void MemoryUniformAction<#= memKey #><in U, <#= GenList("C", n) #>>(U uniform, <#= memSig #>);
<# 
    }
} 
#>

#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member