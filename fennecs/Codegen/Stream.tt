<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".generated.cs" #>
<#@ import namespace="System.Linq" #>
<#
    int maxArity = 5;

    string GenList(string prefix, int n, string sep = ", ", string suffix = "", string format = null) {
        var arr = new string[n];
        for (int i = 0; i < n; i++) {
            arr[i] = format == null ? prefix + i + suffix : string.Format(format, i);
        }
        return string.Join(sep, arr);
    }
    
    string FormatList(int n, string format, string sep) {
        var arr = new string[n];
        for (var i = 0; i < n; i++) {
            arr[i] = string.Format(format, i);
        }
        return string.Join(sep, arr);
    }

    string GenTypeList(int n) => GenList("C", n);
    string GenWhereList(int n) => string.Join(Environment.NewLine + "    ",
        Enumerable.Range(0,n).Select(i=>$"where C{i} : notnull"));
#>
//------------------------------------------------------------------------------
// <auto-generated>
//   This file is generated by Stream.tt
//   Do not modify directly.
//------------------------------------------------------------------------------
using System.Collections;
using System.Collections.Immutable;
using fennecs.pools;
using fennecs;

// Hash: <#= this.GetHashCode() #>

namespace fennecs
{
<#
for (int n=1; n<=maxArity; n++) {
    var types = GenTypeList(n);
#>
    /// <summary>
    /// Auto-generated Stream with arity <#= n #>.
    /// </summary>
    public readonly record struct Stream<<#= types #>>
        : IEnumerable<(Entity, <#= types #>)>
        <#= Environment.NewLine #>    <#= GenWhereList(n) #>
    {
        #region Stream Fields
        private readonly ImmutableArray<TypeExpression> _streamTypes;
        public Query Query { get; }
        public ImmutableSortedSet<Comp> Subset { get; init; } = [];
        public ImmutableSortedSet<Comp> Exclude { get; init; } = [];
        private readonly CountdownEvent _countdown = new(initialCount: 1);

        private SortedSet<Archetype> Archetypes => Query.Archetypes;
        private World World => Query.World;
        private SortedSet<Archetype> Filtered =>
            Subset.IsEmpty && Exclude.IsEmpty
            ? Archetypes
            : new SortedSet<Archetype>(Archetypes.Where(InclusionPredicate));

        private bool InclusionPredicate(Archetype candidate) =>
            (Subset.IsEmpty || candidate.MatchSignature.Matches(Subset)) &&
            !candidate.MatchSignature.Matches(Exclude);

        public int Count => Filtered.Sum(f => f.Count);

        private static int Concurrency => Math.Max(1, Environment.ProcessorCount - 2);
        #endregion

        #region Constructor
        public Stream(Query query<# for (int i=0;i<n;i++){ #>, Match match<#= i #><# } #>)
        {
            _streamTypes = ImmutableArray.Create(
<# for (int i=0;i<n;i++){ #>                TypeExpression.Of<C<#= i #>>(match<#= i #>)<#= i<n-1?",":"" #>
<# } #>);
            Query = query;
        }
        #endregion

        #region Filter State
<# for (int i=0;i<n;i++){ #>
        public ComponentFilter<C<#= i #>> Filter<#= i #> { private get; init; } = (in C<#= i #> _) => true;
<# } #>

        private bool Pass(<#= GenList("", n, ", ", "", "in C{0} c{0}") #>) =>
            <#= string.Join(" && ", Enumerable.Range(0,n).Select(i=>$"Filter{i}(c{i})")) #>;

<# for (int i=0;i<n;i++){ #>
        public Stream<<#= types #>> Where(ComponentFilter<C<#= i #>> filter<#= i #>) =>
            this with { Filter<#= i #> = filter<#= i #> };
<# } #>
        #endregion

        #region For
        public void For(ComponentAction<<#= types #>> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {

                    var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
                    Loop(<#= GenList("s", n,".Span, ") #>, action);
                } while (join.Iterate());
            }
        }

        public void For<U>(U uniform, UniformComponentAction<U, <#= types #>> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
                    LoopUniform(<#= GenList("s",n,".Span, ") #>, action, uniform);
                } while (join.Iterate());
            }
        }

        public void For(EntityComponentAction<<#= types #>> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
                    LoopEntity(table, <#= GenList("s",n,".Span, ") #>, action);
                } while (join.Iterate());
            }
        }

        public void For<U>(U uniform, UniformEntityComponentAction<U, <#= types #>> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
                    LoopUniformEntity(table, <#= GenList("s",n,".Span, ") #>, action, uniform);
                } while (join.Iterate());
            }
        }
        #endregion

        #region Job
        public void Job(ComponentAction<<#= types #>> action)
        {
            AssertNoWildcards(_streamTypes);
            using var worldLock = World.Lock();
            var chunkSize = Math.Max(1, Count / Concurrency);

            _countdown.Reset();
            using var jobs = PooledList<Work<<#= types #>>>.Rent();

            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                var partitions = count / chunkSize + Math.Sign(count % chunkSize);

                do
                {
                    for (var chunk = 0; chunk < partitions; chunk++)
                    {
                        _countdown.AddCount();
                        var start = chunk * chunkSize;
                        var length = Math.Min(chunkSize, count - start);

                        var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
                        var job = JobPool<Work<<#= types #>>>.Rent();
<# for (int i=0;i<n;i++){ #>
                        job.Memory<#= i+1 #> = s<#= i #>.AsMemory(start,length);
<# } #>
                        job.Action = action;
                        job.Pass = Pass;
                        job.CountDown = _countdown;
                        jobs.Add(job);

                        ThreadPool.UnsafeQueueUserWorkItem(job, true);
                    }
                } while (join.Iterate());
            }
            _countdown.Signal();
            _countdown.Wait();
            JobPool<Work<<#= types #>>>.Return(jobs);
        }

        public void Job<U>(U uniform, UniformComponentAction<U, <#= types #>> action)
        {
            AssertNoWildcards(_streamTypes);
            using var worldLock = World.Lock();
            var chunkSize = Math.Max(1, Count / Concurrency);

            _countdown.Reset();
            using var jobs = PooledList<UniformWork<U, <#= types #>>>.Rent();

            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                var partitions = count / chunkSize + Math.Sign(count % chunkSize);

                do
                {
                    for (var chunk = 0; chunk < partitions; chunk++)
                    {
                        _countdown.AddCount();
                        var start = chunk * chunkSize;
                        var length = Math.Min(chunkSize, count - start);

                        var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
                        var job = JobPool<UniformWork<U, <#= types #>>>.Rent();
<# for (int i=0;i<n;i++){ #>
                        job.Memory<#= i+1 #> = s<#= i #>.AsMemory(start,length);
<# } #>
                        job.Action = action;
                        job.Uniform = uniform;
                        job.Pass = Pass;
                        job.CountDown = _countdown;
                        jobs.Add(job);

                        ThreadPool.UnsafeQueueUserWorkItem(job, true);
                    }
                } while (join.Iterate());
            }
            _countdown.Signal();
            _countdown.Wait();
            JobPool<UniformWork<U, <#= types #>>>.Return(jobs);
        }
        #endregion

        #region Raw
        public void Raw(MemoryAction<<#= types #>> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                do
                {
                    var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
<# for (int i=0;i<n;i++){ #>                    var mem<#= i #> = s<#= i #>.AsMemory(0, count);
<# } #>
                    action(<#= GenList("mem",n) #>);
                } while (join.Iterate());
            }
        }

        public void Raw<U>(U uniform, MemoryUniformAction<U, <#= types #>> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                do
                {
                    var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
<# for (int i=0;i<n;i++){ #>                    var mem<#= i #> = s<#= i #>.AsMemory(0, count);
<# } #>
                    action(uniform, <#= GenList("mem",n) #>);
                } while (join.Iterate());
            }
        }
        #endregion

        #region IEnumerable
        public IEnumerator<(Entity, <#= types #>)> GetEnumerator()
        {
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var snapshot = table.Version;
                do
                {
                    var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
                    for (var i=0; i<table.Count; i++)
                    {
                        yield return (table[i], <#= string.Join(", ", Enumerable.Range(0,n).Select(i=>$"s{i}[i]")) #>);
                        if (table.Version != snapshot) throw new InvalidOperationException("Collection was modified during iteration.");
                    }
                } while (join.Iterate());
            }
        }
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        #endregion

        #region Blitters
<# for (int i=0; i<n; i++){ #>
        public void Blit(C<#= i #> value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C<#= i #>>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
<# } #>
        #endregion

        #region Action Loops
        private void Loop(<#= FormatList(n, "Span<C{0}> span{0}", ",") #>, ComponentAction<<#= types #>> action)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(<#= GenList("in span",n,", ", "[i]") #>)) continue;
                action(<#= GenList("ref span",n,", ", "[i]") #>);
            }
        }

        private void LoopEntity(Archetype table, <#= FormatList(n, "Span<C{0}> span{0}", ",") #>, EntityComponentAction<<#= types #>> action)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(<#= GenList("in span",n,", ", "[i]") #>)) continue;
                action(table[i], <#= GenList("ref span",n,", ", "[i]") #>);
            }
        }

        private void LoopUniform<U>(<#= FormatList(n, "Span<C{0}> span{0}", ",") #>, UniformComponentAction<U, <#= types #>> action, U uniform)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(<#= GenList("in span",n,", ", "[i]") #>)) continue;
                action(uniform, <#= GenList("ref span",n,", ", "[i]") #>);
            }
        }

        private void LoopUniformEntity<U>(Archetype table, <#= FormatList(n, "Span<C{0}> span{0}", ",") #>, UniformEntityComponentAction<U, <#= types #>> action, U uniform)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(<#= GenList("in span",n,", ", "[i]") #>)) continue;
                action(uniform, table[i], <#= GenList("ref span",n,", ", "[i]") #>);
            }
        }
        #endregion

        #region Assertions
        private static void AssertNoWildcards(ImmutableArray<TypeExpression> streamTypes)
        {
            if (streamTypes.Any(t => t.isWildcard))
                throw new InvalidOperationException(
                    $"Cannot run this operation on wildcard Stream Types (write destination Aliasing). {streamTypes}");
        }
        #endregion

    #region Query Forwarding
    
    /// <inheritdoc cref="fennecs.Query.Truncate"/>
    public void Truncate(int targetSize, Query.TruncateMode mode = default)
    {
        Query.Truncate(targetSize, mode);
    }
    
    /// <inheritdoc cref="fennecs.Query.Despawn"/>
    public void Despawn()
    {
        foreach (var archetype in Filtered) archetype.Truncate(0);
    }

    #endregion

    }
<#
} // end for n
#>
}