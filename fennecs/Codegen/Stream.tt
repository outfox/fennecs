<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".generated.cs" #>
<#@ import namespace="System.Linq" #>
<#
    const int maxArity = 5; // Maximum number of components in the stream

    // <summary>
    // Generates a list of "prefix + index + suffix" values.
    // Example: GenList("C", 3) => "C0, C1, C2"
    // </summary>
    string GenList(string prefix, int count, string separator = ", ", string suffix = "")
    {
        return string.Join(
            separator,
            Enumerable.Range(0, count).Select(i => $"{prefix}{i}{suffix}")
        );
    }

    // <summary>
    // Generates a list of formatted strings.
    // Example: FormatList(3, "Span<C{0}> span{0}", ",") =>
    //          "Span<C0> span0, Span<C1> span1, Span<C2> span2"
    // </summary>
    string FormatList(int count, string format, string separator = ", ")
    {
        return string.Join(
            separator,
            Enumerable.Range(0, count).Select(i => string.Format(format, i))
        );
    }

    string GenTypeList(int n) =>
        GenList("C", n);

    string GenWhereList(int n) =>
        string.Join(
            Environment.NewLine + "    ",
            Enumerable.Range(0, n).Select(i => $"where C{i} : notnull")
        );
#>
//------------------------------------------------------------------------------
// <auto-generated>
//   This file is generated by Stream.tt
//   Do not modify directly.
//------------------------------------------------------------------------------
using System.Collections;
using System.Collections.Immutable;
using fennecs.pools;
using fennecs;

// Date: <#= DateTime.UtcNow #>

namespace fennecs
{
<#
    for (var n = 1; n <= maxArity; n++)
    {
        var types = GenTypeList(n);
#>
    /// <summary>
    /// Auto-generated Stream with arity <#= n #>.
    /// </summary>
    public readonly record struct Stream<<#= types #>>
        : IEnumerable<(Entity, <#= types #>)>
        <#= Environment.NewLine #>    <#= GenWhereList(n) #>
    {
        #region Stream Fields

        // The component TypeExpressions that this Stream operates on.
        private readonly ImmutableArray<TypeExpression> _streamTypes;

        /// <summary>
        /// The Query this Stream is associated with.
        /// </summary>
        public Query Query { get; }

        /// <summary>
        /// Subset Stream Filter - if not empty, only entities with these components 
        /// will be included in the Stream. 
        /// </summary>
        public ImmutableSortedSet<Comp> Subset { get; init; } = [];
        
        /// <summary>
        /// Exclude Stream Filter - any entities with these components 
        /// will be excluded from the Stream. (none if empty)
        /// </summary>
        public ImmutableSortedSet<Comp> Exclude { get; init; } = [];
        
        // Countdown event used to track completion of jobs.
        private readonly CountdownEvent _countdown = new(initialCount: 1);

        /// <summary>
        /// The Archetypes that the underlying Query matches.
        /// </summary>
        private SortedSet<Archetype> Archetypes => Query.Archetypes;

        // The World that the contained Entities and underlying Query are associated with.
        private World World => Query.World;

        private SortedSet<Archetype> Filtered =>
            Subset.IsEmpty && Exclude.IsEmpty
                ? Archetypes
                : new SortedSet<Archetype>(Archetypes.Where(InclusionPredicate));

        private bool InclusionPredicate(Archetype candidate) =>
            (Subset.IsEmpty || candidate.MatchSignature.Matches(Subset)) &&
            !candidate.MatchSignature.Matches(Exclude);

        /// <summary>
        /// The number of entities that match the underlying Query.
        /// </summary>
        public int Count => Filtered.Sum(f => f.Count);
        
        private static int Concurrency => Math.Max(1, Environment.ProcessorCount - 2);
        #endregion

        #region Constructor
        /// <summary>
        /// Constructs a for a Query operating on the given component types.
        /// </summary>
        public Stream(Query query<# for (var i = 0; i < n; i++) { #>, Match match<#= i #><# } #>)
        {
            _streamTypes = ImmutableArray.Create(
<# for (var i = 0; i < n; i++) { #>                TypeExpression.Of<C<#= i #>>(match<#= i #>)<#= i < n - 1 ? "," : "" #>
<# } #>);
            Query = query;
        }
        #endregion

        #region Filter State
<# for (var i = 0; i < n; i++) { #>
        /// <summary>
        /// Filter for component C<#= i #>.             
        /// </summary>
        /// <remarks> Return true to include the Entity in the Stream, false to skip it. </remarks>
        public ComponentFilter<C<#= i #>> Filter<#= i #> { private get; init; } = (in C<#= i #> _) => true;
<# } #>
        // Internally used default filter that lets all entities pass.
        private bool Pass(<#= FormatList(n, "in C{0} c{0}") #>) =>
            <#= string.Join(" && ", Enumerable.Range(0, n).Select(i => $"Filter{i}(c{i})")) #>;

<# for (var i = 0; i < n; i++) { #>
        /// <summary>
        /// Creates a new Stream with the same Query and Filters, but replacing the 
        /// filter for Component <c>C<#= i #></c> with the provided predicate. 
        /// </summary>
        public Stream<<#= types #>> Where(ComponentFilter<C<#= i #>> filter<#= i #>) =>
            this with { Filter<#= i #> = filter<#= i #> };
<# } #>
        #endregion

        #region For
        /// <include file='../XMLdoc.xml' path='members/member[@name="T:For"]'/>
        public void For(ComponentAction<<#= types #>> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    // (s0, s1, ..., sN) = join.Select
                    var <#= (n > 1 ? "(" : "") + GenList("s", n) + (n > 1 ? ")" : "")  #> = join.Select;
                    Loop(<#= GenList("s", n, ".Span, ") #>, action);
                } while (join.Iterate());
            }
        }

        /// <include file='../XMLdoc.xml' path='members/member[@name="T:ForU"]'/>
        public void For<U>(U uniform, UniformComponentAction<U, <#= types #>> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    // (s0, s1, ..., sN) = join.Select
                    var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
                    LoopUniform(<#= GenList("s",n,".Span, ") #>, action, uniform);
                } while (join.Iterate());
            }
        }

        /// <include file='../XMLdoc.xml' path='members/member[@name="T:ForE"]'/>
        public void For(EntityComponentAction<<#= types #>> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    // (s0, s1, ..., sN) = join.Select
                    var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
                    LoopEntity(table, <#= GenList("s",n,".Span, ") #>, action);
                } while (join.Iterate());
            }
        }

        /// <include file='../XMLdoc.xml' path='members/member[@name="T:ForEU"]'/>
        public void For<U>(U uniform, UniformEntityComponentAction<U, <#= types #>> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    // (s0, s1, ..., sN) = join.Select
                    var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
                    LoopUniformEntity(table, <#= GenList("s",n,".Span, ") #>, action, uniform);
                } while (join.Iterate());
            }
        }
        #endregion

        #region Job
        /// <inheritdoc cref="Stream{C0}.Job"/>
        public void Job(ComponentAction<<#= types #>> action)
        {
            AssertNoWildcards(_streamTypes);
            using var worldLock = World.Lock();
            var chunkSize = Math.Max(1, Count / Concurrency);

            _countdown.Reset();
            using var jobs = PooledList<Work<<#= types #>>>.Rent();

            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                var partitions = count / chunkSize + Math.Sign(count % chunkSize);

                do
                {
                    for (var chunk = 0; chunk < partitions; chunk++)
                    {
                        _countdown.AddCount();
                        var start = chunk * chunkSize;
                        var length = Math.Min(chunkSize, count - start);

                        var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
                        var job = JobPool<Work<<#= types #>>>.Rent();
<# for (var i=0;i<n;i++){ #>
                        job.Memory<#= i+1 #> = s<#= i #>.AsMemory(start,length);
<# } #>
                        job.Action = action;
                        job.Pass = Pass;
                        job.CountDown = _countdown;
                        jobs.Add(job);

                        ThreadPool.UnsafeQueueUserWorkItem(job, true);
                    }
                } while (join.Iterate());
            }
            _countdown.Signal();
            _countdown.Wait();
            JobPool<Work<<#= types #>>>.Return(jobs);
        }

        /// <inheritdoc cref="Stream{C0}.Job{U}"/>
        public void Job<U>(U uniform, UniformComponentAction<U, <#= types #>> action)
        {
            AssertNoWildcards(_streamTypes);
            using var worldLock = World.Lock();
            var chunkSize = Math.Max(1, Count / Concurrency);

            _countdown.Reset();
            using var jobs = PooledList<UniformWork<U, <#= types #>>>.Rent();

            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                var partitions = count / chunkSize + Math.Sign(count % chunkSize);

                do
                {
                    for (var chunk = 0; chunk < partitions; chunk++)
                    {
                        _countdown.AddCount();
                        var start = chunk * chunkSize;
                        var length = Math.Min(chunkSize, count - start);

                        var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
                        var job = JobPool<UniformWork<U, <#= types #>>>.Rent();
<# for (var i=0;i<n;i++){ #>
                        job.Memory<#= i+1 #> = s<#= i #>.AsMemory(start,length);
<# } #>
                        job.Action = action;
                        job.Uniform = uniform;
                        job.Pass = Pass;
                        job.CountDown = _countdown;
                        jobs.Add(job);

                        ThreadPool.UnsafeQueueUserWorkItem(job, true);
                    }
                } while (join.Iterate());
            }
            _countdown.Signal();
            _countdown.Wait();
            JobPool<UniformWork<U, <#= types #>>>.Return(jobs);
        }
        #endregion

        #region Raw
        /// <inheritdoc cref="Stream{C0}.Raw"/>
        public void Raw(MemoryAction<<#= types #>> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                do
                {
                    var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
<# for (var i=0;i<n;i++){ #>                    var mem<#= i #> = s<#= i #>.AsMemory(0, count);
<# } #>
                    action(<#= GenList("mem",n) #>);
                } while (join.Iterate());
            }
        }

        /// <inheritdoc cref="Stream{C0}.Raw{U}"/>
        public void Raw<U>(U uniform, MemoryUniformAction<U, <#= types #>> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                do
                {
                    var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
<# for (var i=0;i<n;i++){ #>                    
                    var mem<#= i #> = s<#= i #>.AsMemory(0, count);
<# } #>
                    action(uniform, <#= GenList("mem",n) #>);
                } while (join.Iterate());
            }
        }
        #endregion

        #region IEnumerable
        /// <inheritdoc />
        public IEnumerator<(Entity, <#= types #>)> GetEnumerator()
        {
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<<#= types #>>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var snapshot = table.Version;
                do
                {
                    var <#= (n > 1 ? "(" : "") + GenList("s",n) + (n > 1 ? ")" : "")  #> = join.Select;
                    for (var i=0; i<table.Count; i++)
                    {
                        yield return (table[i], <#= string.Join(", ", Enumerable.Range(0,n).Select(i=>$"s{i}[i]")) #>);
                        if (table.Version != snapshot) throw new InvalidOperationException("Collection was modified during iteration.");
                    }
                } while (join.Iterate());
            }
        }
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        #endregion

        #region Blitters
<# for (var i=0; i<n; i++){ #>
        /// <summary>
        /// Blit (write) a component value of type <c>C<#= i #>></c>
        /// to all entities matched by this query. 
        /// </summary>
        public void Blit(C<#= i #> value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C<#= i #>>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
<# } #>
        #endregion

        #region Action Loops
        private void Loop(<#= FormatList(n, "Span<C{0}> span{0}", ",") #>, ComponentAction<<#= types #>> action)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(<#= FormatList(n,"in span{0}[i]") #>)) continue;
                action(<#= FormatList(n,"ref span{0}[i]") #>);
            }
        }

        private void LoopEntity(Archetype table, <#= FormatList(n, "Span<C{0}> span{0}", ",") #>, EntityComponentAction<<#= types #>> action)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(<#= FormatList(n,"in span{0}[i]") #>)) continue;
                action(table[i], <#= FormatList(n,"ref span{0}[i]") #>);
            }
        }

        private void LoopUniform<U>(<#= FormatList(n, "Span<C{0}> span{0}", ",") #>, UniformComponentAction<U, <#= types #>> action, U uniform)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(<#= FormatList(n,"in span{0}[i]") #>)) continue;
                action(uniform, <#= FormatList(n,"ref span{0}[i]") #>);
            }
        }

        private void LoopUniformEntity<U>(Archetype table, <#= FormatList(n, "Span<C{0}> span{0}", ",") #>, UniformEntityComponentAction<U, <#= types #>> action, U uniform)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(<#= FormatList(n,"in span{0}[i]") #>)) continue;
                action(uniform, table[i], <#= FormatList(n,"ref span{0}[i]") #>);
            }
        }
        #endregion

        #region Assertions
        private static void AssertNoWildcards(ImmutableArray<TypeExpression> streamTypes)
        {
            if (streamTypes.Any(t => t.isWildcard))
                throw new InvalidOperationException(
                    $"Cannot run this operation on wildcard Stream Types (write destination Aliasing). {streamTypes}");
        }
        #endregion

        #region Query Forwarding
    
        /// <inheritdoc cref="fennecs.Query.Truncate"/>
        public void Truncate(int targetSize, Query.TruncateMode mode = default)
        {
            Query.Truncate(targetSize, mode);
        }
    
        /// <inheritdoc cref="fennecs.Query.Despawn"/>
        public void Despawn()
        {
            foreach (var archetype in Filtered) archetype.Truncate(0);
        }

        #endregion
    }
<#
    } // end for n
#>
}