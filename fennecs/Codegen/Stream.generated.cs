//------------------------------------------------------------------------------
// <auto-generated>
//   This file is generated by Stream.tt
//   Do not modify directly.
//------------------------------------------------------------------------------
using System.Collections;
using System.Collections.Immutable;
using fennecs.pools;
using fennecs;

// Hash: 1707556

namespace fennecs
{
    /// <summary>
    /// Auto-generated Stream with arity 1.
    /// </summary>
    public readonly record struct Stream<C0>
        : IEnumerable<(Entity, C0)>
        
    where C0 : notnull
    {
        #region Stream Fields
        private readonly ImmutableArray<TypeExpression> _streamTypes;
        public Query Query { get; }
        public ImmutableSortedSet<Comp> Subset { get; init; } = [];
        public ImmutableSortedSet<Comp> Exclude { get; init; } = [];
        private readonly CountdownEvent _countdown = new(initialCount: 1);

        private SortedSet<Archetype> Archetypes => Query.Archetypes;
        private World World => Query.World;
        private SortedSet<Archetype> Filtered =>
            Subset.IsEmpty && Exclude.IsEmpty
            ? Archetypes
            : new SortedSet<Archetype>(Archetypes.Where(InclusionPredicate));

        private bool InclusionPredicate(Archetype candidate) =>
            (Subset.IsEmpty || candidate.MatchSignature.Matches(Subset)) &&
            !candidate.MatchSignature.Matches(Exclude);

        public int Count => Filtered.Sum(f => f.Count);

        private static int Concurrency => Math.Max(1, Environment.ProcessorCount - 2);
        #endregion

        #region Constructor
        public Stream(Query query, Match match0)
        {
            _streamTypes = ImmutableArray.Create(
                TypeExpression.Of<C0>(match0)
);
            Query = query;
        }
        #endregion

        #region Filter State
        public ComponentFilter<C0> Filter0 { private get; init; } = (in C0 _) => true;

        private bool Pass(in C0 c0) =>
            Filter0(c0);

        public Stream<C0> Where(ComponentFilter<C0> filter0) =>
            this with { Filter0 = filter0 };
        #endregion

        #region For
        public void For(ComponentAction<C0> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {

                    var s0 = join.Select;
                    Loop(s0, action);
                } while (join.Iterate());
            }
        }

        public void For<U>(U uniform, UniformComponentAction<U, C0> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var s0 = join.Select;
                    LoopUniform(s0, action, uniform);
                } while (join.Iterate());
            }
        }

        public void For(EntityComponentAction<C0> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var s0 = join.Select;
                    LoopEntity(table, s0, action);
                } while (join.Iterate());
            }
        }

        public void For<U>(U uniform, UniformEntityComponentAction<U, C0> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var s0 = join.Select;
                    LoopUniformEntity(table, s0, action, uniform);
                } while (join.Iterate());
            }
        }
        #endregion

        #region Job
        public void Job(ComponentAction<C0> action)
        {
            AssertNoWildcards(_streamTypes);
            using var worldLock = World.Lock();
            var chunkSize = Math.Max(1, Count / Concurrency);

            _countdown.Reset();
            using var jobs = PooledList<Work<C0>>.Rent();

            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                var partitions = count / chunkSize + Math.Sign(count % chunkSize);

                do
                {
                    for (var chunk = 0; chunk < partitions; chunk++)
                    {
                        _countdown.AddCount();
                        var start = chunk * chunkSize;
                        var length = Math.Min(chunkSize, count - start);

                        var s0 = join.Select;
                        var job = JobPool<Work<C0>>.Rent();
                        job.Memory1 = s0.AsMemory(start,length);
                        job.Action = action;
                        job.Pass = Pass;
                        job.CountDown = _countdown;
                        jobs.Add(job);

                        ThreadPool.UnsafeQueueUserWorkItem(job, true);
                    }
                } while (join.Iterate());
            }
            _countdown.Signal();
            _countdown.Wait();
            JobPool<Work<C0>>.Return(jobs);
        }

        public void Job<U>(U uniform, UniformComponentAction<U, C0> action)
        {
            AssertNoWildcards(_streamTypes);
            using var worldLock = World.Lock();
            var chunkSize = Math.Max(1, Count / Concurrency);

            _countdown.Reset();
            using var jobs = PooledList<UniformWork<U, C0>>.Rent();

            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                var partitions = count / chunkSize + Math.Sign(count % chunkSize);

                do
                {
                    for (var chunk = 0; chunk < partitions; chunk++)
                    {
                        _countdown.AddCount();
                        var start = chunk * chunkSize;
                        var length = Math.Min(chunkSize, count - start);

                        var s0 = join.Select;
                        var job = JobPool<UniformWork<U, C0>>.Rent();
                        job.Memory1 = s0.AsMemory(start,length);
                        job.Action = action;
                        job.Uniform = uniform;
                        job.Pass = Pass;
                        job.CountDown = _countdown;
                        jobs.Add(job);

                        ThreadPool.UnsafeQueueUserWorkItem(job, true);
                    }
                } while (join.Iterate());
            }
            _countdown.Signal();
            _countdown.Wait();
            JobPool<UniformWork<U, C0>>.Return(jobs);
        }
        #endregion

        #region Raw
        public void Raw(MemoryAction<C0> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                do
                {
                    var s0 = join.Select;
                    var mem0 = s0.AsMemory(0, count);
                    action(mem0);
                } while (join.Iterate());
            }
        }

        public void Raw<U>(U uniform, MemoryUniformAction<U, C0> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                do
                {
                    var s0 = join.Select;
                    var mem0 = s0.AsMemory(0, count);
                    action(uniform, mem0);
                } while (join.Iterate());
            }
        }
        #endregion

        #region IEnumerable
        public IEnumerator<(Entity, C0)> GetEnumerator()
        {
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var snapshot = table.Version;
                do
                {
                    var s0 = join.Select;
                    for (var i=0; i<table.Count; i++)
                    {
                        yield return (table[i], s0[i]);
                        if (table.Version != snapshot) throw new InvalidOperationException("Collection was modified during iteration.");
                    }
                } while (join.Iterate());
            }
        }
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        #endregion

        #region Blitters
        public void Blit(C0 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C0>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        #endregion

        #region Action Loops
        private void Loop(Span<C0> span0, ComponentAction<C0> action)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i])) continue;
                action(ref span0[i]);
            }
        }

        private void LoopEntity(Archetype table, Span<C0> span0, EntityComponentAction<C0> action)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i])) continue;
                action(table[i], ref span0[i]);
            }
        }

        private void LoopUniform<U>(Span<C0> span0, UniformComponentAction<U, C0> action, U uniform)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i])) continue;
                action(uniform, ref span0[i]);
            }
        }

        private void LoopUniformEntity<U>(Archetype table, Span<C0> span0, UniformEntityComponentAction<U, C0> action, U uniform)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i])) continue;
                action(uniform, table[i], ref span0[i]);
            }
        }
        #endregion

        #region Assertions
        private static void AssertNoWildcards(ImmutableArray<TypeExpression> streamTypes)
        {
            if (streamTypes.Any(t => t.isWildcard))
                throw new InvalidOperationException(
                    $"Cannot run this operation on wildcard Stream Types (write destination Aliasing). {streamTypes}");
        }
        #endregion

    #region Query Forwarding
    
    /// <inheritdoc cref="fennecs.Query.Truncate"/>
    public void Truncate(int targetSize, Query.TruncateMode mode = default)
    {
        Query.Truncate(targetSize, mode);
    }
    
    /// <inheritdoc cref="fennecs.Query.Despawn"/>
    public void Despawn()
    {
        foreach (var archetype in Filtered) archetype.Truncate(0);
    }

    #endregion

    }
    /// <summary>
    /// Auto-generated Stream with arity 2.
    /// </summary>
    public readonly record struct Stream<C0, C1>
        : IEnumerable<(Entity, C0, C1)>
        
    where C0 : notnull
    where C1 : notnull
    {
        #region Stream Fields
        private readonly ImmutableArray<TypeExpression> _streamTypes;
        public Query Query { get; }
        public ImmutableSortedSet<Comp> Subset { get; init; } = [];
        public ImmutableSortedSet<Comp> Exclude { get; init; } = [];
        private readonly CountdownEvent _countdown = new(initialCount: 1);

        private SortedSet<Archetype> Archetypes => Query.Archetypes;
        private World World => Query.World;
        private SortedSet<Archetype> Filtered =>
            Subset.IsEmpty && Exclude.IsEmpty
            ? Archetypes
            : new SortedSet<Archetype>(Archetypes.Where(InclusionPredicate));

        private bool InclusionPredicate(Archetype candidate) =>
            (Subset.IsEmpty || candidate.MatchSignature.Matches(Subset)) &&
            !candidate.MatchSignature.Matches(Exclude);

        public int Count => Filtered.Sum(f => f.Count);

        private static int Concurrency => Math.Max(1, Environment.ProcessorCount - 2);
        #endregion

        #region Constructor
        public Stream(Query query, Match match0, Match match1)
        {
            _streamTypes = ImmutableArray.Create(
                TypeExpression.Of<C0>(match0),
                TypeExpression.Of<C1>(match1)
);
            Query = query;
        }
        #endregion

        #region Filter State
        public ComponentFilter<C0> Filter0 { private get; init; } = (in C0 _) => true;
        public ComponentFilter<C1> Filter1 { private get; init; } = (in C1 _) => true;

        private bool Pass(in C0 c0, in C1 c1) =>
            Filter0(c0) && Filter1(c1);

        public Stream<C0, C1> Where(ComponentFilter<C0> filter0) =>
            this with { Filter0 = filter0 };
        public Stream<C0, C1> Where(ComponentFilter<C1> filter1) =>
            this with { Filter1 = filter1 };
        #endregion

        #region For
        public void For(ComponentAction<C0, C1> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {

                    var (s0, s1) = join.Select;
                    Loop(s0.Span, s1, action);
                } while (join.Iterate());
            }
        }

        public void For<U>(U uniform, UniformComponentAction<U, C0, C1> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var (s0, s1) = join.Select;
                    LoopUniform(s0.Span, s1, action, uniform);
                } while (join.Iterate());
            }
        }

        public void For(EntityComponentAction<C0, C1> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var (s0, s1) = join.Select;
                    LoopEntity(table, s0.Span, s1, action);
                } while (join.Iterate());
            }
        }

        public void For<U>(U uniform, UniformEntityComponentAction<U, C0, C1> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var (s0, s1) = join.Select;
                    LoopUniformEntity(table, s0.Span, s1, action, uniform);
                } while (join.Iterate());
            }
        }
        #endregion

        #region Job
        public void Job(ComponentAction<C0, C1> action)
        {
            AssertNoWildcards(_streamTypes);
            using var worldLock = World.Lock();
            var chunkSize = Math.Max(1, Count / Concurrency);

            _countdown.Reset();
            using var jobs = PooledList<Work<C0, C1>>.Rent();

            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                var partitions = count / chunkSize + Math.Sign(count % chunkSize);

                do
                {
                    for (var chunk = 0; chunk < partitions; chunk++)
                    {
                        _countdown.AddCount();
                        var start = chunk * chunkSize;
                        var length = Math.Min(chunkSize, count - start);

                        var (s0, s1) = join.Select;
                        var job = JobPool<Work<C0, C1>>.Rent();
                        job.Memory1 = s0.AsMemory(start,length);
                        job.Memory2 = s1.AsMemory(start,length);
                        job.Action = action;
                        job.Pass = Pass;
                        job.CountDown = _countdown;
                        jobs.Add(job);

                        ThreadPool.UnsafeQueueUserWorkItem(job, true);
                    }
                } while (join.Iterate());
            }
            _countdown.Signal();
            _countdown.Wait();
            JobPool<Work<C0, C1>>.Return(jobs);
        }

        public void Job<U>(U uniform, UniformComponentAction<U, C0, C1> action)
        {
            AssertNoWildcards(_streamTypes);
            using var worldLock = World.Lock();
            var chunkSize = Math.Max(1, Count / Concurrency);

            _countdown.Reset();
            using var jobs = PooledList<UniformWork<U, C0, C1>>.Rent();

            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                var partitions = count / chunkSize + Math.Sign(count % chunkSize);

                do
                {
                    for (var chunk = 0; chunk < partitions; chunk++)
                    {
                        _countdown.AddCount();
                        var start = chunk * chunkSize;
                        var length = Math.Min(chunkSize, count - start);

                        var (s0, s1) = join.Select;
                        var job = JobPool<UniformWork<U, C0, C1>>.Rent();
                        job.Memory1 = s0.AsMemory(start,length);
                        job.Memory2 = s1.AsMemory(start,length);
                        job.Action = action;
                        job.Uniform = uniform;
                        job.Pass = Pass;
                        job.CountDown = _countdown;
                        jobs.Add(job);

                        ThreadPool.UnsafeQueueUserWorkItem(job, true);
                    }
                } while (join.Iterate());
            }
            _countdown.Signal();
            _countdown.Wait();
            JobPool<UniformWork<U, C0, C1>>.Return(jobs);
        }
        #endregion

        #region Raw
        public void Raw(MemoryAction<C0, C1> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                do
                {
                    var (s0, s1) = join.Select;
                    var mem0 = s0.AsMemory(0, count);
                    var mem1 = s1.AsMemory(0, count);
                    action(mem0, mem1);
                } while (join.Iterate());
            }
        }

        public void Raw<U>(U uniform, MemoryUniformAction<U, C0, C1> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                do
                {
                    var (s0, s1) = join.Select;
                    var mem0 = s0.AsMemory(0, count);
                    var mem1 = s1.AsMemory(0, count);
                    action(uniform, mem0, mem1);
                } while (join.Iterate());
            }
        }
        #endregion

        #region IEnumerable
        public IEnumerator<(Entity, C0, C1)> GetEnumerator()
        {
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var snapshot = table.Version;
                do
                {
                    var (s0, s1) = join.Select;
                    for (var i=0; i<table.Count; i++)
                    {
                        yield return (table[i], s0[i], s1[i]);
                        if (table.Version != snapshot) throw new InvalidOperationException("Collection was modified during iteration.");
                    }
                } while (join.Iterate());
            }
        }
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        #endregion

        #region Blitters
        public void Blit(C0 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C0>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        public void Blit(C1 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C1>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        #endregion

        #region Action Loops
        private void Loop(Span<C0> span0,Span<C1> span1, ComponentAction<C0, C1> action)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i])) continue;
                action(ref span0[i], ref span1[i]);
            }
        }

        private void LoopEntity(Archetype table, Span<C0> span0,Span<C1> span1, EntityComponentAction<C0, C1> action)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i])) continue;
                action(table[i], ref span0[i], ref span1[i]);
            }
        }

        private void LoopUniform<U>(Span<C0> span0,Span<C1> span1, UniformComponentAction<U, C0, C1> action, U uniform)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i])) continue;
                action(uniform, ref span0[i], ref span1[i]);
            }
        }

        private void LoopUniformEntity<U>(Archetype table, Span<C0> span0,Span<C1> span1, UniformEntityComponentAction<U, C0, C1> action, U uniform)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i])) continue;
                action(uniform, table[i], ref span0[i], ref span1[i]);
            }
        }
        #endregion

        #region Assertions
        private static void AssertNoWildcards(ImmutableArray<TypeExpression> streamTypes)
        {
            if (streamTypes.Any(t => t.isWildcard))
                throw new InvalidOperationException(
                    $"Cannot run this operation on wildcard Stream Types (write destination Aliasing). {streamTypes}");
        }
        #endregion

    #region Query Forwarding
    
    /// <inheritdoc cref="fennecs.Query.Truncate"/>
    public void Truncate(int targetSize, Query.TruncateMode mode = default)
    {
        Query.Truncate(targetSize, mode);
    }
    
    /// <inheritdoc cref="fennecs.Query.Despawn"/>
    public void Despawn()
    {
        foreach (var archetype in Filtered) archetype.Truncate(0);
    }

    #endregion

    }
    /// <summary>
    /// Auto-generated Stream with arity 3.
    /// </summary>
    public readonly record struct Stream<C0, C1, C2>
        : IEnumerable<(Entity, C0, C1, C2)>
        
    where C0 : notnull
    where C1 : notnull
    where C2 : notnull
    {
        #region Stream Fields
        private readonly ImmutableArray<TypeExpression> _streamTypes;
        public Query Query { get; }
        public ImmutableSortedSet<Comp> Subset { get; init; } = [];
        public ImmutableSortedSet<Comp> Exclude { get; init; } = [];
        private readonly CountdownEvent _countdown = new(initialCount: 1);

        private SortedSet<Archetype> Archetypes => Query.Archetypes;
        private World World => Query.World;
        private SortedSet<Archetype> Filtered =>
            Subset.IsEmpty && Exclude.IsEmpty
            ? Archetypes
            : new SortedSet<Archetype>(Archetypes.Where(InclusionPredicate));

        private bool InclusionPredicate(Archetype candidate) =>
            (Subset.IsEmpty || candidate.MatchSignature.Matches(Subset)) &&
            !candidate.MatchSignature.Matches(Exclude);

        public int Count => Filtered.Sum(f => f.Count);

        private static int Concurrency => Math.Max(1, Environment.ProcessorCount - 2);
        #endregion

        #region Constructor
        public Stream(Query query, Match match0, Match match1, Match match2)
        {
            _streamTypes = ImmutableArray.Create(
                TypeExpression.Of<C0>(match0),
                TypeExpression.Of<C1>(match1),
                TypeExpression.Of<C2>(match2)
);
            Query = query;
        }
        #endregion

        #region Filter State
        public ComponentFilter<C0> Filter0 { private get; init; } = (in C0 _) => true;
        public ComponentFilter<C1> Filter1 { private get; init; } = (in C1 _) => true;
        public ComponentFilter<C2> Filter2 { private get; init; } = (in C2 _) => true;

        private bool Pass(in C0 c0, in C1 c1, in C2 c2) =>
            Filter0(c0) && Filter1(c1) && Filter2(c2);

        public Stream<C0, C1, C2> Where(ComponentFilter<C0> filter0) =>
            this with { Filter0 = filter0 };
        public Stream<C0, C1, C2> Where(ComponentFilter<C1> filter1) =>
            this with { Filter1 = filter1 };
        public Stream<C0, C1, C2> Where(ComponentFilter<C2> filter2) =>
            this with { Filter2 = filter2 };
        #endregion

        #region For
        public void For(ComponentAction<C0, C1, C2> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {

                    var (s0, s1, s2) = join.Select;
                    Loop(s0.Span, s1.Span, s2, action);
                } while (join.Iterate());
            }
        }

        public void For<U>(U uniform, UniformComponentAction<U, C0, C1, C2> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var (s0, s1, s2) = join.Select;
                    LoopUniform(s0.Span, s1.Span, s2, action, uniform);
                } while (join.Iterate());
            }
        }

        public void For(EntityComponentAction<C0, C1, C2> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var (s0, s1, s2) = join.Select;
                    LoopEntity(table, s0.Span, s1.Span, s2, action);
                } while (join.Iterate());
            }
        }

        public void For<U>(U uniform, UniformEntityComponentAction<U, C0, C1, C2> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var (s0, s1, s2) = join.Select;
                    LoopUniformEntity(table, s0.Span, s1.Span, s2, action, uniform);
                } while (join.Iterate());
            }
        }
        #endregion

        #region Job
        public void Job(ComponentAction<C0, C1, C2> action)
        {
            AssertNoWildcards(_streamTypes);
            using var worldLock = World.Lock();
            var chunkSize = Math.Max(1, Count / Concurrency);

            _countdown.Reset();
            using var jobs = PooledList<Work<C0, C1, C2>>.Rent();

            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                var partitions = count / chunkSize + Math.Sign(count % chunkSize);

                do
                {
                    for (var chunk = 0; chunk < partitions; chunk++)
                    {
                        _countdown.AddCount();
                        var start = chunk * chunkSize;
                        var length = Math.Min(chunkSize, count - start);

                        var (s0, s1, s2) = join.Select;
                        var job = JobPool<Work<C0, C1, C2>>.Rent();
                        job.Memory1 = s0.AsMemory(start,length);
                        job.Memory2 = s1.AsMemory(start,length);
                        job.Memory3 = s2.AsMemory(start,length);
                        job.Action = action;
                        job.Pass = Pass;
                        job.CountDown = _countdown;
                        jobs.Add(job);

                        ThreadPool.UnsafeQueueUserWorkItem(job, true);
                    }
                } while (join.Iterate());
            }
            _countdown.Signal();
            _countdown.Wait();
            JobPool<Work<C0, C1, C2>>.Return(jobs);
        }

        public void Job<U>(U uniform, UniformComponentAction<U, C0, C1, C2> action)
        {
            AssertNoWildcards(_streamTypes);
            using var worldLock = World.Lock();
            var chunkSize = Math.Max(1, Count / Concurrency);

            _countdown.Reset();
            using var jobs = PooledList<UniformWork<U, C0, C1, C2>>.Rent();

            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                var partitions = count / chunkSize + Math.Sign(count % chunkSize);

                do
                {
                    for (var chunk = 0; chunk < partitions; chunk++)
                    {
                        _countdown.AddCount();
                        var start = chunk * chunkSize;
                        var length = Math.Min(chunkSize, count - start);

                        var (s0, s1, s2) = join.Select;
                        var job = JobPool<UniformWork<U, C0, C1, C2>>.Rent();
                        job.Memory1 = s0.AsMemory(start,length);
                        job.Memory2 = s1.AsMemory(start,length);
                        job.Memory3 = s2.AsMemory(start,length);
                        job.Action = action;
                        job.Uniform = uniform;
                        job.Pass = Pass;
                        job.CountDown = _countdown;
                        jobs.Add(job);

                        ThreadPool.UnsafeQueueUserWorkItem(job, true);
                    }
                } while (join.Iterate());
            }
            _countdown.Signal();
            _countdown.Wait();
            JobPool<UniformWork<U, C0, C1, C2>>.Return(jobs);
        }
        #endregion

        #region Raw
        public void Raw(MemoryAction<C0, C1, C2> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                do
                {
                    var (s0, s1, s2) = join.Select;
                    var mem0 = s0.AsMemory(0, count);
                    var mem1 = s1.AsMemory(0, count);
                    var mem2 = s2.AsMemory(0, count);
                    action(mem0, mem1, mem2);
                } while (join.Iterate());
            }
        }

        public void Raw<U>(U uniform, MemoryUniformAction<U, C0, C1, C2> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                do
                {
                    var (s0, s1, s2) = join.Select;
                    var mem0 = s0.AsMemory(0, count);
                    var mem1 = s1.AsMemory(0, count);
                    var mem2 = s2.AsMemory(0, count);
                    action(uniform, mem0, mem1, mem2);
                } while (join.Iterate());
            }
        }
        #endregion

        #region IEnumerable
        public IEnumerator<(Entity, C0, C1, C2)> GetEnumerator()
        {
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var snapshot = table.Version;
                do
                {
                    var (s0, s1, s2) = join.Select;
                    for (var i=0; i<table.Count; i++)
                    {
                        yield return (table[i], s0[i], s1[i], s2[i]);
                        if (table.Version != snapshot) throw new InvalidOperationException("Collection was modified during iteration.");
                    }
                } while (join.Iterate());
            }
        }
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        #endregion

        #region Blitters
        public void Blit(C0 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C0>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        public void Blit(C1 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C1>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        public void Blit(C2 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C2>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        #endregion

        #region Action Loops
        private void Loop(Span<C0> span0,Span<C1> span1,Span<C2> span2, ComponentAction<C0, C1, C2> action)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i], in span2[i])) continue;
                action(ref span0[i], ref span1[i], ref span2[i]);
            }
        }

        private void LoopEntity(Archetype table, Span<C0> span0,Span<C1> span1,Span<C2> span2, EntityComponentAction<C0, C1, C2> action)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i], in span2[i])) continue;
                action(table[i], ref span0[i], ref span1[i], ref span2[i]);
            }
        }

        private void LoopUniform<U>(Span<C0> span0,Span<C1> span1,Span<C2> span2, UniformComponentAction<U, C0, C1, C2> action, U uniform)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i], in span2[i])) continue;
                action(uniform, ref span0[i], ref span1[i], ref span2[i]);
            }
        }

        private void LoopUniformEntity<U>(Archetype table, Span<C0> span0,Span<C1> span1,Span<C2> span2, UniformEntityComponentAction<U, C0, C1, C2> action, U uniform)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i], in span2[i])) continue;
                action(uniform, table[i], ref span0[i], ref span1[i], ref span2[i]);
            }
        }
        #endregion

        #region Assertions
        private static void AssertNoWildcards(ImmutableArray<TypeExpression> streamTypes)
        {
            if (streamTypes.Any(t => t.isWildcard))
                throw new InvalidOperationException(
                    $"Cannot run this operation on wildcard Stream Types (write destination Aliasing). {streamTypes}");
        }
        #endregion

    #region Query Forwarding
    
    /// <inheritdoc cref="fennecs.Query.Truncate"/>
    public void Truncate(int targetSize, Query.TruncateMode mode = default)
    {
        Query.Truncate(targetSize, mode);
    }
    
    /// <inheritdoc cref="fennecs.Query.Despawn"/>
    public void Despawn()
    {
        foreach (var archetype in Filtered) archetype.Truncate(0);
    }

    #endregion

    }
    /// <summary>
    /// Auto-generated Stream with arity 4.
    /// </summary>
    public readonly record struct Stream<C0, C1, C2, C3>
        : IEnumerable<(Entity, C0, C1, C2, C3)>
        
    where C0 : notnull
    where C1 : notnull
    where C2 : notnull
    where C3 : notnull
    {
        #region Stream Fields
        private readonly ImmutableArray<TypeExpression> _streamTypes;
        public Query Query { get; }
        public ImmutableSortedSet<Comp> Subset { get; init; } = [];
        public ImmutableSortedSet<Comp> Exclude { get; init; } = [];
        private readonly CountdownEvent _countdown = new(initialCount: 1);

        private SortedSet<Archetype> Archetypes => Query.Archetypes;
        private World World => Query.World;
        private SortedSet<Archetype> Filtered =>
            Subset.IsEmpty && Exclude.IsEmpty
            ? Archetypes
            : new SortedSet<Archetype>(Archetypes.Where(InclusionPredicate));

        private bool InclusionPredicate(Archetype candidate) =>
            (Subset.IsEmpty || candidate.MatchSignature.Matches(Subset)) &&
            !candidate.MatchSignature.Matches(Exclude);

        public int Count => Filtered.Sum(f => f.Count);

        private static int Concurrency => Math.Max(1, Environment.ProcessorCount - 2);
        #endregion

        #region Constructor
        public Stream(Query query, Match match0, Match match1, Match match2, Match match3)
        {
            _streamTypes = ImmutableArray.Create(
                TypeExpression.Of<C0>(match0),
                TypeExpression.Of<C1>(match1),
                TypeExpression.Of<C2>(match2),
                TypeExpression.Of<C3>(match3)
);
            Query = query;
        }
        #endregion

        #region Filter State
        public ComponentFilter<C0> Filter0 { private get; init; } = (in C0 _) => true;
        public ComponentFilter<C1> Filter1 { private get; init; } = (in C1 _) => true;
        public ComponentFilter<C2> Filter2 { private get; init; } = (in C2 _) => true;
        public ComponentFilter<C3> Filter3 { private get; init; } = (in C3 _) => true;

        private bool Pass(in C0 c0, in C1 c1, in C2 c2, in C3 c3) =>
            Filter0(c0) && Filter1(c1) && Filter2(c2) && Filter3(c3);

        public Stream<C0, C1, C2, C3> Where(ComponentFilter<C0> filter0) =>
            this with { Filter0 = filter0 };
        public Stream<C0, C1, C2, C3> Where(ComponentFilter<C1> filter1) =>
            this with { Filter1 = filter1 };
        public Stream<C0, C1, C2, C3> Where(ComponentFilter<C2> filter2) =>
            this with { Filter2 = filter2 };
        public Stream<C0, C1, C2, C3> Where(ComponentFilter<C3> filter3) =>
            this with { Filter3 = filter3 };
        #endregion

        #region For
        public void For(ComponentAction<C0, C1, C2, C3> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {

                    var (s0, s1, s2, s3) = join.Select;
                    Loop(s0.Span, s1.Span, s2.Span, s3, action);
                } while (join.Iterate());
            }
        }

        public void For<U>(U uniform, UniformComponentAction<U, C0, C1, C2, C3> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var (s0, s1, s2, s3) = join.Select;
                    LoopUniform(s0.Span, s1.Span, s2.Span, s3, action, uniform);
                } while (join.Iterate());
            }
        }

        public void For(EntityComponentAction<C0, C1, C2, C3> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var (s0, s1, s2, s3) = join.Select;
                    LoopEntity(table, s0.Span, s1.Span, s2.Span, s3, action);
                } while (join.Iterate());
            }
        }

        public void For<U>(U uniform, UniformEntityComponentAction<U, C0, C1, C2, C3> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var (s0, s1, s2, s3) = join.Select;
                    LoopUniformEntity(table, s0.Span, s1.Span, s2.Span, s3, action, uniform);
                } while (join.Iterate());
            }
        }
        #endregion

        #region Job
        public void Job(ComponentAction<C0, C1, C2, C3> action)
        {
            AssertNoWildcards(_streamTypes);
            using var worldLock = World.Lock();
            var chunkSize = Math.Max(1, Count / Concurrency);

            _countdown.Reset();
            using var jobs = PooledList<Work<C0, C1, C2, C3>>.Rent();

            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                var partitions = count / chunkSize + Math.Sign(count % chunkSize);

                do
                {
                    for (var chunk = 0; chunk < partitions; chunk++)
                    {
                        _countdown.AddCount();
                        var start = chunk * chunkSize;
                        var length = Math.Min(chunkSize, count - start);

                        var (s0, s1, s2, s3) = join.Select;
                        var job = JobPool<Work<C0, C1, C2, C3>>.Rent();
                        job.Memory1 = s0.AsMemory(start,length);
                        job.Memory2 = s1.AsMemory(start,length);
                        job.Memory3 = s2.AsMemory(start,length);
                        job.Memory4 = s3.AsMemory(start,length);
                        job.Action = action;
                        job.Pass = Pass;
                        job.CountDown = _countdown;
                        jobs.Add(job);

                        ThreadPool.UnsafeQueueUserWorkItem(job, true);
                    }
                } while (join.Iterate());
            }
            _countdown.Signal();
            _countdown.Wait();
            JobPool<Work<C0, C1, C2, C3>>.Return(jobs);
        }

        public void Job<U>(U uniform, UniformComponentAction<U, C0, C1, C2, C3> action)
        {
            AssertNoWildcards(_streamTypes);
            using var worldLock = World.Lock();
            var chunkSize = Math.Max(1, Count / Concurrency);

            _countdown.Reset();
            using var jobs = PooledList<UniformWork<U, C0, C1, C2, C3>>.Rent();

            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                var partitions = count / chunkSize + Math.Sign(count % chunkSize);

                do
                {
                    for (var chunk = 0; chunk < partitions; chunk++)
                    {
                        _countdown.AddCount();
                        var start = chunk * chunkSize;
                        var length = Math.Min(chunkSize, count - start);

                        var (s0, s1, s2, s3) = join.Select;
                        var job = JobPool<UniformWork<U, C0, C1, C2, C3>>.Rent();
                        job.Memory1 = s0.AsMemory(start,length);
                        job.Memory2 = s1.AsMemory(start,length);
                        job.Memory3 = s2.AsMemory(start,length);
                        job.Memory4 = s3.AsMemory(start,length);
                        job.Action = action;
                        job.Uniform = uniform;
                        job.Pass = Pass;
                        job.CountDown = _countdown;
                        jobs.Add(job);

                        ThreadPool.UnsafeQueueUserWorkItem(job, true);
                    }
                } while (join.Iterate());
            }
            _countdown.Signal();
            _countdown.Wait();
            JobPool<UniformWork<U, C0, C1, C2, C3>>.Return(jobs);
        }
        #endregion

        #region Raw
        public void Raw(MemoryAction<C0, C1, C2, C3> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                do
                {
                    var (s0, s1, s2, s3) = join.Select;
                    var mem0 = s0.AsMemory(0, count);
                    var mem1 = s1.AsMemory(0, count);
                    var mem2 = s2.AsMemory(0, count);
                    var mem3 = s3.AsMemory(0, count);
                    action(mem0, mem1, mem2, mem3);
                } while (join.Iterate());
            }
        }

        public void Raw<U>(U uniform, MemoryUniformAction<U, C0, C1, C2, C3> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                do
                {
                    var (s0, s1, s2, s3) = join.Select;
                    var mem0 = s0.AsMemory(0, count);
                    var mem1 = s1.AsMemory(0, count);
                    var mem2 = s2.AsMemory(0, count);
                    var mem3 = s3.AsMemory(0, count);
                    action(uniform, mem0, mem1, mem2, mem3);
                } while (join.Iterate());
            }
        }
        #endregion

        #region IEnumerable
        public IEnumerator<(Entity, C0, C1, C2, C3)> GetEnumerator()
        {
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var snapshot = table.Version;
                do
                {
                    var (s0, s1, s2, s3) = join.Select;
                    for (var i=0; i<table.Count; i++)
                    {
                        yield return (table[i], s0[i], s1[i], s2[i], s3[i]);
                        if (table.Version != snapshot) throw new InvalidOperationException("Collection was modified during iteration.");
                    }
                } while (join.Iterate());
            }
        }
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        #endregion

        #region Blitters
        public void Blit(C0 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C0>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        public void Blit(C1 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C1>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        public void Blit(C2 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C2>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        public void Blit(C3 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C3>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        #endregion

        #region Action Loops
        private void Loop(Span<C0> span0,Span<C1> span1,Span<C2> span2,Span<C3> span3, ComponentAction<C0, C1, C2, C3> action)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i], in span2[i], in span3[i])) continue;
                action(ref span0[i], ref span1[i], ref span2[i], ref span3[i]);
            }
        }

        private void LoopEntity(Archetype table, Span<C0> span0,Span<C1> span1,Span<C2> span2,Span<C3> span3, EntityComponentAction<C0, C1, C2, C3> action)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i], in span2[i], in span3[i])) continue;
                action(table[i], ref span0[i], ref span1[i], ref span2[i], ref span3[i]);
            }
        }

        private void LoopUniform<U>(Span<C0> span0,Span<C1> span1,Span<C2> span2,Span<C3> span3, UniformComponentAction<U, C0, C1, C2, C3> action, U uniform)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i], in span2[i], in span3[i])) continue;
                action(uniform, ref span0[i], ref span1[i], ref span2[i], ref span3[i]);
            }
        }

        private void LoopUniformEntity<U>(Archetype table, Span<C0> span0,Span<C1> span1,Span<C2> span2,Span<C3> span3, UniformEntityComponentAction<U, C0, C1, C2, C3> action, U uniform)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i], in span2[i], in span3[i])) continue;
                action(uniform, table[i], ref span0[i], ref span1[i], ref span2[i], ref span3[i]);
            }
        }
        #endregion

        #region Assertions
        private static void AssertNoWildcards(ImmutableArray<TypeExpression> streamTypes)
        {
            if (streamTypes.Any(t => t.isWildcard))
                throw new InvalidOperationException(
                    $"Cannot run this operation on wildcard Stream Types (write destination Aliasing). {streamTypes}");
        }
        #endregion

    #region Query Forwarding
    
    /// <inheritdoc cref="fennecs.Query.Truncate"/>
    public void Truncate(int targetSize, Query.TruncateMode mode = default)
    {
        Query.Truncate(targetSize, mode);
    }
    
    /// <inheritdoc cref="fennecs.Query.Despawn"/>
    public void Despawn()
    {
        foreach (var archetype in Filtered) archetype.Truncate(0);
    }

    #endregion

    }
    /// <summary>
    /// Auto-generated Stream with arity 5.
    /// </summary>
    public readonly record struct Stream<C0, C1, C2, C3, C4>
        : IEnumerable<(Entity, C0, C1, C2, C3, C4)>
        
    where C0 : notnull
    where C1 : notnull
    where C2 : notnull
    where C3 : notnull
    where C4 : notnull
    {
        #region Stream Fields
        private readonly ImmutableArray<TypeExpression> _streamTypes;
        public Query Query { get; }
        public ImmutableSortedSet<Comp> Subset { get; init; } = [];
        public ImmutableSortedSet<Comp> Exclude { get; init; } = [];
        private readonly CountdownEvent _countdown = new(initialCount: 1);

        private SortedSet<Archetype> Archetypes => Query.Archetypes;
        private World World => Query.World;
        private SortedSet<Archetype> Filtered =>
            Subset.IsEmpty && Exclude.IsEmpty
            ? Archetypes
            : new SortedSet<Archetype>(Archetypes.Where(InclusionPredicate));

        private bool InclusionPredicate(Archetype candidate) =>
            (Subset.IsEmpty || candidate.MatchSignature.Matches(Subset)) &&
            !candidate.MatchSignature.Matches(Exclude);

        public int Count => Filtered.Sum(f => f.Count);

        private static int Concurrency => Math.Max(1, Environment.ProcessorCount - 2);
        #endregion

        #region Constructor
        public Stream(Query query, Match match0, Match match1, Match match2, Match match3, Match match4)
        {
            _streamTypes = ImmutableArray.Create(
                TypeExpression.Of<C0>(match0),
                TypeExpression.Of<C1>(match1),
                TypeExpression.Of<C2>(match2),
                TypeExpression.Of<C3>(match3),
                TypeExpression.Of<C4>(match4)
);
            Query = query;
        }
        #endregion

        #region Filter State
        public ComponentFilter<C0> Filter0 { private get; init; } = (in C0 _) => true;
        public ComponentFilter<C1> Filter1 { private get; init; } = (in C1 _) => true;
        public ComponentFilter<C2> Filter2 { private get; init; } = (in C2 _) => true;
        public ComponentFilter<C3> Filter3 { private get; init; } = (in C3 _) => true;
        public ComponentFilter<C4> Filter4 { private get; init; } = (in C4 _) => true;

        private bool Pass(in C0 c0, in C1 c1, in C2 c2, in C3 c3, in C4 c4) =>
            Filter0(c0) && Filter1(c1) && Filter2(c2) && Filter3(c3) && Filter4(c4);

        public Stream<C0, C1, C2, C3, C4> Where(ComponentFilter<C0> filter0) =>
            this with { Filter0 = filter0 };
        public Stream<C0, C1, C2, C3, C4> Where(ComponentFilter<C1> filter1) =>
            this with { Filter1 = filter1 };
        public Stream<C0, C1, C2, C3, C4> Where(ComponentFilter<C2> filter2) =>
            this with { Filter2 = filter2 };
        public Stream<C0, C1, C2, C3, C4> Where(ComponentFilter<C3> filter3) =>
            this with { Filter3 = filter3 };
        public Stream<C0, C1, C2, C3, C4> Where(ComponentFilter<C4> filter4) =>
            this with { Filter4 = filter4 };
        #endregion

        #region For
        public void For(ComponentAction<C0, C1, C2, C3, C4> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {

                    var (s0, s1, s2, s3, s4) = join.Select;
                    Loop(s0.Span, s1.Span, s2.Span, s3.Span, s4, action);
                } while (join.Iterate());
            }
        }

        public void For<U>(U uniform, UniformComponentAction<U, C0, C1, C2, C3, C4> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var (s0, s1, s2, s3, s4) = join.Select;
                    LoopUniform(s0.Span, s1.Span, s2.Span, s3.Span, s4, action, uniform);
                } while (join.Iterate());
            }
        }

        public void For(EntityComponentAction<C0, C1, C2, C3, C4> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var (s0, s1, s2, s3, s4) = join.Select;
                    LoopEntity(table, s0.Span, s1.Span, s2.Span, s3.Span, s4, action);
                } while (join.Iterate());
            }
        }

        public void For<U>(U uniform, UniformEntityComponentAction<U, C0, C1, C2, C3, C4> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                do
                {
                    var (s0, s1, s2, s3, s4) = join.Select;
                    LoopUniformEntity(table, s0.Span, s1.Span, s2.Span, s3.Span, s4, action, uniform);
                } while (join.Iterate());
            }
        }
        #endregion

        #region Job
        public void Job(ComponentAction<C0, C1, C2, C3, C4> action)
        {
            AssertNoWildcards(_streamTypes);
            using var worldLock = World.Lock();
            var chunkSize = Math.Max(1, Count / Concurrency);

            _countdown.Reset();
            using var jobs = PooledList<Work<C0, C1, C2, C3, C4>>.Rent();

            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                var partitions = count / chunkSize + Math.Sign(count % chunkSize);

                do
                {
                    for (var chunk = 0; chunk < partitions; chunk++)
                    {
                        _countdown.AddCount();
                        var start = chunk * chunkSize;
                        var length = Math.Min(chunkSize, count - start);

                        var (s0, s1, s2, s3, s4) = join.Select;
                        var job = JobPool<Work<C0, C1, C2, C3, C4>>.Rent();
                        job.Memory1 = s0.AsMemory(start,length);
                        job.Memory2 = s1.AsMemory(start,length);
                        job.Memory3 = s2.AsMemory(start,length);
                        job.Memory4 = s3.AsMemory(start,length);
                        job.Memory5 = s4.AsMemory(start,length);
                        job.Action = action;
                        job.Pass = Pass;
                        job.CountDown = _countdown;
                        jobs.Add(job);

                        ThreadPool.UnsafeQueueUserWorkItem(job, true);
                    }
                } while (join.Iterate());
            }
            _countdown.Signal();
            _countdown.Wait();
            JobPool<Work<C0, C1, C2, C3, C4>>.Return(jobs);
        }

        public void Job<U>(U uniform, UniformComponentAction<U, C0, C1, C2, C3, C4> action)
        {
            AssertNoWildcards(_streamTypes);
            using var worldLock = World.Lock();
            var chunkSize = Math.Max(1, Count / Concurrency);

            _countdown.Reset();
            using var jobs = PooledList<UniformWork<U, C0, C1, C2, C3, C4>>.Rent();

            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                var partitions = count / chunkSize + Math.Sign(count % chunkSize);

                do
                {
                    for (var chunk = 0; chunk < partitions; chunk++)
                    {
                        _countdown.AddCount();
                        var start = chunk * chunkSize;
                        var length = Math.Min(chunkSize, count - start);

                        var (s0, s1, s2, s3, s4) = join.Select;
                        var job = JobPool<UniformWork<U, C0, C1, C2, C3, C4>>.Rent();
                        job.Memory1 = s0.AsMemory(start,length);
                        job.Memory2 = s1.AsMemory(start,length);
                        job.Memory3 = s2.AsMemory(start,length);
                        job.Memory4 = s3.AsMemory(start,length);
                        job.Memory5 = s4.AsMemory(start,length);
                        job.Action = action;
                        job.Uniform = uniform;
                        job.Pass = Pass;
                        job.CountDown = _countdown;
                        jobs.Add(job);

                        ThreadPool.UnsafeQueueUserWorkItem(job, true);
                    }
                } while (join.Iterate());
            }
            _countdown.Signal();
            _countdown.Wait();
            JobPool<UniformWork<U, C0, C1, C2, C3, C4>>.Return(jobs);
        }
        #endregion

        #region Raw
        public void Raw(MemoryAction<C0, C1, C2, C3, C4> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                do
                {
                    var (s0, s1, s2, s3, s4) = join.Select;
                    var mem0 = s0.AsMemory(0, count);
                    var mem1 = s1.AsMemory(0, count);
                    var mem2 = s2.AsMemory(0, count);
                    var mem3 = s3.AsMemory(0, count);
                    var mem4 = s4.AsMemory(0, count);
                    action(mem0, mem1, mem2, mem3, mem4);
                } while (join.Iterate());
            }
        }

        public void Raw<U>(U uniform, MemoryUniformAction<U, C0, C1, C2, C3, C4> action)
        {
            using var worldLock = World.Lock();
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var count = table.Count;
                do
                {
                    var (s0, s1, s2, s3, s4) = join.Select;
                    var mem0 = s0.AsMemory(0, count);
                    var mem1 = s1.AsMemory(0, count);
                    var mem2 = s2.AsMemory(0, count);
                    var mem3 = s3.AsMemory(0, count);
                    var mem4 = s4.AsMemory(0, count);
                    action(uniform, mem0, mem1, mem2, mem3, mem4);
                } while (join.Iterate());
            }
        }
        #endregion

        #region IEnumerable
        public IEnumerator<(Entity, C0, C1, C2, C3, C4)> GetEnumerator()
        {
            foreach (var table in Filtered)
            {
                using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
                if (join.Empty) continue;
                var snapshot = table.Version;
                do
                {
                    var (s0, s1, s2, s3, s4) = join.Select;
                    for (var i=0; i<table.Count; i++)
                    {
                        yield return (table[i], s0[i], s1[i], s2[i], s3[i], s4[i]);
                        if (table.Version != snapshot) throw new InvalidOperationException("Collection was modified during iteration.");
                    }
                } while (join.Iterate());
            }
        }
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        #endregion

        #region Blitters
        public void Blit(C0 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C0>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        public void Blit(C1 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C1>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        public void Blit(C2 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C2>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        public void Blit(C3 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C3>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        public void Blit(C4 value, Match match = default)
        {
            var typeExpression = TypeExpression.Of<C4>(match);
            foreach (var table in Filtered)
                table.Fill(typeExpression, value);
        }
        #endregion

        #region Action Loops
        private void Loop(Span<C0> span0,Span<C1> span1,Span<C2> span2,Span<C3> span3,Span<C4> span4, ComponentAction<C0, C1, C2, C3, C4> action)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i], in span2[i], in span3[i], in span4[i])) continue;
                action(ref span0[i], ref span1[i], ref span2[i], ref span3[i], ref span4[i]);
            }
        }

        private void LoopEntity(Archetype table, Span<C0> span0,Span<C1> span1,Span<C2> span2,Span<C3> span3,Span<C4> span4, EntityComponentAction<C0, C1, C2, C3, C4> action)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i], in span2[i], in span3[i], in span4[i])) continue;
                action(table[i], ref span0[i], ref span1[i], ref span2[i], ref span3[i], ref span4[i]);
            }
        }

        private void LoopUniform<U>(Span<C0> span0,Span<C1> span1,Span<C2> span2,Span<C3> span3,Span<C4> span4, UniformComponentAction<U, C0, C1, C2, C3, C4> action, U uniform)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i], in span2[i], in span3[i], in span4[i])) continue;
                action(uniform, ref span0[i], ref span1[i], ref span2[i], ref span3[i], ref span4[i]);
            }
        }

        private void LoopUniformEntity<U>(Archetype table, Span<C0> span0,Span<C1> span1,Span<C2> span2,Span<C3> span3,Span<C4> span4, UniformEntityComponentAction<U, C0, C1, C2, C3, C4> action, U uniform)
        {
            var length = span0.Length;
            for (var i=0;i<length;i++)
            {
                if (!Pass(in span0[i], in span1[i], in span2[i], in span3[i], in span4[i])) continue;
                action(uniform, table[i], ref span0[i], ref span1[i], ref span2[i], ref span3[i], ref span4[i]);
            }
        }
        #endregion

        #region Assertions
        private static void AssertNoWildcards(ImmutableArray<TypeExpression> streamTypes)
        {
            if (streamTypes.Any(t => t.isWildcard))
                throw new InvalidOperationException(
                    $"Cannot run this operation on wildcard Stream Types (write destination Aliasing). {streamTypes}");
        }
        #endregion

    #region Query Forwarding
    
    /// <inheritdoc cref="fennecs.Query.Truncate"/>
    public void Truncate(int targetSize, Query.TruncateMode mode = default)
    {
        Query.Truncate(targetSize, mode);
    }
    
    /// <inheritdoc cref="fennecs.Query.Despawn"/>
    public void Despawn()
    {
        foreach (var archetype in Filtered) archetype.Truncate(0);
    }

    #endregion

    }
}