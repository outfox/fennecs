// <auto-generated/>
using System.Runtime.CompilerServices;
using fennecs.pools;
using fennecs.storage;

namespace fennecs;
public partial record Stream<C0>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000001)]
        public void Raw(Action<ReadOnlySpan<C0>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var s0 = join.Select;
                   action(s0.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000001)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var s0 = join.Select;
                   action(uniform, s0.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000000)]
        public void Raw(Action<Span<C0>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var s0 = join.Select;
                   action(s0.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000000)]
        public void Raw<U>(U uniform, Action<U, Span<C0>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var s0 = join.Select;
                   action(uniform, s0.Span);
               } while (join.Iterate());
           }
        }


}


public partial record Stream<C0, C1>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000011)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000011)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000010)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000010)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000001)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000001)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000000)]
        public void Raw(Action<Span<C0>, Span<C1>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(s0.Span, s1.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000000)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(uniform, s0.Span, s1.Span);
               } while (join.Iterate());
           }
        }


}


public partial record Stream<C0, C1, C2>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000111)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000111)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000110)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000110)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000101)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000101)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000100)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, Span<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000100)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, Span<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000011)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000011)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000010)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, Span<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000010)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, Span<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000001)]
        public void Raw(Action<Span<C0>, Span<C1>, ReadOnlySpan<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.Span, s1.Span, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000001)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, ReadOnlySpan<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000000)]
        public void Raw(Action<Span<C0>, Span<C1>, Span<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.Span, s1.Span, s2.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000000)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, Span<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.Span);
               } while (join.Iterate());
           }
        }


}


public partial record Stream<C0, C1, C2, C3>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001111)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001111)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001110)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001110)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001101)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001101)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001100)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001100)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001011)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001011)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001010)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001010)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001001)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001001)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001000)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, Span<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001000)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, Span<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000111)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000111)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000110)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000110)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000101)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000101)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000100)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000100)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000011)]
        public void Raw(Action<Span<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000011)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000010)]
        public void Raw(Action<Span<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.Span, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000010)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000001)]
        public void Raw(Action<Span<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.Span, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000001)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000000)]
        public void Raw(Action<Span<C0>, Span<C1>, Span<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.Span, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000000)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, Span<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }


}


public partial record Stream<C0, C1, C2, C3, C4>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00011111)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00011111)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00011110)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00011110)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00011101)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00011101)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00011100)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00011100)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00011011)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00011011)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00011010)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00011010)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00011001)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00011001)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00011000)]
        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00011000)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00010111)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00010111)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00010110)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00010110)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00010101)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00010101)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00010100)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00010100)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00010011)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00010011)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00010010)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00010010)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00010001)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00010001)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00010000)]
        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, Span<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00010000)]
        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, Span<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001111)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001111)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001110)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001110)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001101)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001101)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001100)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001100)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001011)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001011)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001010)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001010)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001001)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001001)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00001000)]
        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00001000)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000111)]
        public void Raw(Action<Span<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000111)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000110)]
        public void Raw(Action<Span<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000110)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000101)]
        public void Raw(Action<Span<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000101)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000100)]
        public void Raw(Action<Span<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000100)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000011)]
        public void Raw(Action<Span<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000011)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000010)]
        public void Raw(Action<Span<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000010)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000001)]
        public void Raw(Action<Span<C0>, Span<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000001)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(0b_00000000_00000000)]
        public void Raw(Action<Span<C0>, Span<C1>, Span<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(0b_00000000_00000000)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, Span<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }


}


