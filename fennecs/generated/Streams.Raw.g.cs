// <auto-generated/>
using System.Runtime.CompilerServices;
using fennecs.pools;
using fennecs.storage;

namespace fennecs;
public partial record Stream<C0>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var s0 = join.Select;
                   action(s0.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var s0 = join.Select;
                   action(uniform, s0.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(9001)]
        public void Raw(Action<Span<C0>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var s0 = join.Select;
                   action(s0.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(9001)]
        public void Raw<U>(U uniform, Action<U, Span<C0>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var s0 = join.Select;
                   action(uniform, s0.Span);
               } while (join.Iterate());
           }
        }


}


public partial record Stream<C0, C1>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(9001)]
        public void Raw(Action<Span<C0>, Span<C1>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(s0.Span, s1.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(9001)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1) = join.Select;
                   action(uniform, s0.Span, s1.Span);
               } while (join.Iterate());
           }
        }


}


public partial record Stream<C0, C1, C2>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, Span<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, Span<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, Span<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, Span<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, Span<C1>, ReadOnlySpan<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.Span, s1.Span, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, ReadOnlySpan<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(9001)]
        public void Raw(Action<Span<C0>, Span<C1>, Span<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(s0.Span, s1.Span, s2.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(9001)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, Span<C2>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.Span);
               } while (join.Iterate());
           }
        }


}


public partial record Stream<C0, C1, C2, C3>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, Span<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, Span<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.Span, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.ReadOnlySpan, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.Span, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.Span, s3.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(9001)]
        public void Raw(Action<Span<C0>, Span<C1>, Span<C2>, Span<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(s0.Span, s1.Span, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(9001)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, Span<C2>, Span<C3>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.Span, s3.Span);
               } while (join.Iterate());
           }
        }


}


public partial record Stream<C0, C1, C2, C3, C4>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.ReadOnlySpan, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<ReadOnlySpan<C0>, Span<C1>, Span<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.ReadOnlySpan, s1.Span, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, ReadOnlySpan<C0>, Span<C1>, Span<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.ReadOnlySpan, s1.Span, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.ReadOnlySpan, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, ReadOnlySpan<C1>, Span<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.ReadOnlySpan, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, ReadOnlySpan<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.ReadOnlySpan, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.ReadOnlySpan, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, ReadOnlySpan<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.ReadOnlySpan, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.Span, s3.ReadOnlySpan, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, Span<C2>, ReadOnlySpan<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.Span, s3.ReadOnlySpan, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>

        public void Raw(Action<Span<C0>, Span<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>

        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, Span<C2>, Span<C3>, ReadOnlySpan<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.Span, s3.Span, s4.ReadOnlySpan);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:Raw"]'/>
        [OverloadResolutionPriority(9001)]
        public void Raw(Action<Span<C0>, Span<C1>, Span<C2>, Span<C3>, Span<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(s0.Span, s1.Span, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }



        /// <include file='../_docs.xml' path='members/member[@name="T:RawU"]'/>
        [OverloadResolutionPriority(9001)]
        public void Raw<U>(U uniform, Action<U, Span<C0>, Span<C1>, Span<C2>, Span<C3>, Span<C4>> action) where U : allows ref struct
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   action(uniform, s0.Span, s1.Span, s2.Span, s3.Span, s4.Span);
               } while (join.Iterate());
           }
        }


}


