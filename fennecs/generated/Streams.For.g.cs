// <auto-generated/>
using System.Runtime.CompilerServices;
using fennecs.pools;
using fennecs.storage;

namespace fennecs;

public partial record Stream<C0>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:For"]'/>
        public void For(Action<RW<C0>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[1];

               var count = table.Count;
               do
               {
                   var s0 = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(ref span0[i], ref writes[0], in entity, in type0));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForE"]'/>
        public void For(Action<EntityRef, RW<C0>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[1];

               var count = table.Count;
               do
               {
                   var s0 = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(in entity), new(ref span0[i], ref writes[0], in entity, in type0));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForU"]'/>
        public void For<U>(U uniform, Action<U, RW<C0>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[1];

               var count = table.Count;
               do
               {
                   var s0 = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(uniform, new(ref span0[i], ref writes[0], in entity, in type0));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForEU"]'/>
        public void For<U>(U uniform, Action<EntityRef, U, RW<C0>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[1];

               var count = table.Count;
               do
               {
                   var s0 = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(in entity), uniform, new(ref span0[i], ref writes[0], in entity, in type0));
                   }
               } while (join.Iterate());
           }
        }

}


public partial record Stream<C0, C1>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:For"]'/>
        public void For(Action<RW<C0>, RW<C1>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[2];

               var count = table.Count;
               do
               {
                   var (s0, s1) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForE"]'/>
        public void For(Action<EntityRef, RW<C0>, RW<C1>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[2];

               var count = table.Count;
               do
               {
                   var (s0, s1) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(in entity), new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForU"]'/>
        public void For<U>(U uniform, Action<U, RW<C0>, RW<C1>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[2];

               var count = table.Count;
               do
               {
                   var (s0, s1) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(uniform, new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForEU"]'/>
        public void For<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[2];

               var count = table.Count;
               do
               {
                   var (s0, s1) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(in entity), uniform, new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1));
                   }
               } while (join.Iterate());
           }
        }

}


public partial record Stream<C0, C1, C2>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:For"]'/>
        public void For(Action<RW<C0>, RW<C1>, RW<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[3];

               var count = table.Count;
               do
               {
                   var (s0, s1, s2) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression; var span2 = s2.Span; var type2 = s2.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1), new(ref span2[i], ref writes[2], in entity, in type2));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForE"]'/>
        public void For(Action<EntityRef, RW<C0>, RW<C1>, RW<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[3];

               var count = table.Count;
               do
               {
                   var (s0, s1, s2) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression; var span2 = s2.Span; var type2 = s2.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(in entity), new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1), new(ref span2[i], ref writes[2], in entity, in type2));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForU"]'/>
        public void For<U>(U uniform, Action<U, RW<C0>, RW<C1>, RW<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[3];

               var count = table.Count;
               do
               {
                   var (s0, s1, s2) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression; var span2 = s2.Span; var type2 = s2.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(uniform, new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1), new(ref span2[i], ref writes[2], in entity, in type2));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForEU"]'/>
        public void For<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, RW<C2>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[3];

               var count = table.Count;
               do
               {
                   var (s0, s1, s2) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression; var span2 = s2.Span; var type2 = s2.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(in entity), uniform, new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1), new(ref span2[i], ref writes[2], in entity, in type2));
                   }
               } while (join.Iterate());
           }
        }

}


public partial record Stream<C0, C1, C2, C3>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:For"]'/>
        public void For(Action<RW<C0>, RW<C1>, RW<C2>, RW<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[4];

               var count = table.Count;
               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression; var span2 = s2.Span; var type2 = s2.Expression; var span3 = s3.Span; var type3 = s3.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1), new(ref span2[i], ref writes[2], in entity, in type2), new(ref span3[i], ref writes[3], in entity, in type3));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForE"]'/>
        public void For(Action<EntityRef, RW<C0>, RW<C1>, RW<C2>, RW<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[4];

               var count = table.Count;
               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression; var span2 = s2.Span; var type2 = s2.Expression; var span3 = s3.Span; var type3 = s3.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(in entity), new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1), new(ref span2[i], ref writes[2], in entity, in type2), new(ref span3[i], ref writes[3], in entity, in type3));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForU"]'/>
        public void For<U>(U uniform, Action<U, RW<C0>, RW<C1>, RW<C2>, RW<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[4];

               var count = table.Count;
               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression; var span2 = s2.Span; var type2 = s2.Expression; var span3 = s3.Span; var type3 = s3.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(uniform, new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1), new(ref span2[i], ref writes[2], in entity, in type2), new(ref span3[i], ref writes[3], in entity, in type3));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForEU"]'/>
        public void For<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, RW<C2>, RW<C3>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[4];

               var count = table.Count;
               do
               {
                   var (s0, s1, s2, s3) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression; var span2 = s2.Span; var type2 = s2.Expression; var span3 = s3.Span; var type3 = s3.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(in entity), uniform, new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1), new(ref span2[i], ref writes[2], in entity, in type2), new(ref span3[i], ref writes[3], in entity, in type3));
                   }
               } while (join.Iterate());
           }
        }

}


public partial record Stream<C0, C1, C2, C3, C4>
{

        /// <include file='../_docs.xml' path='members/member[@name="T:For"]'/>
        public void For(Action<RW<C0>, RW<C1>, RW<C2>, RW<C3>, RW<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[5];

               var count = table.Count;
               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression; var span2 = s2.Span; var type2 = s2.Expression; var span3 = s3.Span; var type3 = s3.Expression; var span4 = s4.Span; var type4 = s4.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1), new(ref span2[i], ref writes[2], in entity, in type2), new(ref span3[i], ref writes[3], in entity, in type3), new(ref span4[i], ref writes[4], in entity, in type4));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForE"]'/>
        public void For(Action<EntityRef, RW<C0>, RW<C1>, RW<C2>, RW<C3>, RW<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[5];

               var count = table.Count;
               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression; var span2 = s2.Span; var type2 = s2.Expression; var span3 = s3.Span; var type3 = s3.Expression; var span4 = s4.Span; var type4 = s4.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(in entity), new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1), new(ref span2[i], ref writes[2], in entity, in type2), new(ref span3[i], ref writes[3], in entity, in type3), new(ref span4[i], ref writes[4], in entity, in type4));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForU"]'/>
        public void For<U>(U uniform, Action<U, RW<C0>, RW<C1>, RW<C2>, RW<C3>, RW<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[5];

               var count = table.Count;
               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression; var span2 = s2.Span; var type2 = s2.Expression; var span3 = s3.Span; var type3 = s3.Expression; var span4 = s4.Span; var type4 = s4.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(uniform, new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1), new(ref span2[i], ref writes[2], in entity, in type2), new(ref span3[i], ref writes[3], in entity, in type3), new(ref span4[i], ref writes[4], in entity, in type4));
                   }
               } while (join.Iterate());
           }
        }


        /// <include file='../_docs.xml' path='members/member[@name="T:ForEU"]'/>
        public void For<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, RW<C2>, RW<C3>, RW<C4>> action)
        {
           using var worldLock = World.Lock();

           foreach (var table in Filtered)
           {
               using var join = table.CrossJoin<C0, C1, C2, C3, C4>(StreamTypes.AsSpan());
               if (join.Empty) continue;

               Span<bool> writes = stackalloc bool[5];

               var count = table.Count;
               do
               {
                   var (s0, s1, s2, s3, s4) = join.Select;
                   var span0 = s0.Span; var type0 = s0.Expression; var span1 = s1.Span; var type1 = s1.Expression; var span2 = s2.Span; var type2 = s2.Expression; var span3 = s3.Span; var type3 = s3.Expression; var span4 = s4.Span; var type4 = s4.Expression;
                   for (var i = 0; i < count; i++)
                   {
                       var entity = table[i];
                       action(new(in entity), uniform, new(ref span0[i], ref writes[0], in entity, in type0), new(ref span1[i], ref writes[1], in entity, in type1), new(ref span2[i], ref writes[2], in entity, in type2), new(ref span3[i], ref writes[3], in entity, in type3), new(ref span4[i], ref writes[4], in entity, in type4));
                   }
               } while (join.Iterate());
           }
        }

}


