// <auto-generated/>
using System.Runtime.CompilerServices;
using fennecs.pools;
using fennecs.storage;

// ReSharper disable InconsistentNaming

namespace fennecs;
public partial record Stream<C0>
{

    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000001)]
    public void Job(Action<R<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00000010_00000001)]
    public void Job(Action<EntityRef, R<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000001)]
    public void Job<U>(U uniform, Action<U, R<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00000010_00000001)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000000)]
    public void Job(Action<RW<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00000010_00000000)]
    public void Job(Action<EntityRef, RW<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000000)]
    public void Job<U>(U uniform, Action<U, RW<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00000010_00000000)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0));
               }
           } while (join.Iterate());
       }
    }


}
public partial record Stream<C0, C1>
{

    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000011)]
    public void Job(Action<R<C0>, R<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00000100_00000011)]
    public void Job(Action<EntityRef, R<C0>, R<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000011)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00000100_00000011)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000010)]
    public void Job(Action<R<C0>, RW<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00000100_00000010)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000010)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00000100_00000010)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000001)]
    public void Job(Action<RW<C0>, R<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00000100_00000001)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000001)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00000100_00000001)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000000)]
    public void Job(Action<RW<C0>, RW<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00000100_00000000)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000000)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00000100_00000000)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1));
               }
           } while (join.Iterate());
       }
    }


}
public partial record Stream<C0, C1, C2>
{

    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000111)]
    public void Job(Action<R<C0>, R<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00001000_00000111)]
    public void Job(Action<EntityRef, R<C0>, R<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000111)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00001000_00000111)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000110)]
    public void Job(Action<R<C0>, R<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00001000_00000110)]
    public void Job(Action<EntityRef, R<C0>, R<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000110)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00001000_00000110)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000101)]
    public void Job(Action<R<C0>, RW<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00001000_00000101)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000101)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00001000_00000101)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000100)]
    public void Job(Action<R<C0>, RW<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00001000_00000100)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000100)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00001000_00000100)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000011)]
    public void Job(Action<RW<C0>, R<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00001000_00000011)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000011)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00001000_00000011)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000010)]
    public void Job(Action<RW<C0>, R<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00001000_00000010)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000010)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00001000_00000010)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000001)]
    public void Job(Action<RW<C0>, RW<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00001000_00000001)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000001)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00001000_00000001)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, R<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000000)]
    public void Job(Action<RW<C0>, RW<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00001000_00000000)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000000)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00001000_00000000)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, RW<C2>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2));
               }
           } while (join.Iterate());
       }
    }


}
public partial record Stream<C0, C1, C2, C3>
{

    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001111)]
    public void Job(Action<R<C0>, R<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00001111)]
    public void Job(Action<EntityRef, R<C0>, R<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001111)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00001111)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001110)]
    public void Job(Action<R<C0>, R<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00001110)]
    public void Job(Action<EntityRef, R<C0>, R<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001110)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00001110)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001101)]
    public void Job(Action<R<C0>, R<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00001101)]
    public void Job(Action<EntityRef, R<C0>, R<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001101)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00001101)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001100)]
    public void Job(Action<R<C0>, R<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00001100)]
    public void Job(Action<EntityRef, R<C0>, R<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001100)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00001100)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001011)]
    public void Job(Action<R<C0>, RW<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00001011)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001011)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00001011)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001010)]
    public void Job(Action<R<C0>, RW<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00001010)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001010)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00001010)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001001)]
    public void Job(Action<R<C0>, RW<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00001001)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001001)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00001001)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001000)]
    public void Job(Action<R<C0>, RW<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00001000)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001000)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00001000)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000111)]
    public void Job(Action<RW<C0>, R<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00000111)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000111)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00000111)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000110)]
    public void Job(Action<RW<C0>, R<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00000110)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000110)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00000110)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000101)]
    public void Job(Action<RW<C0>, R<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00000101)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000101)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00000101)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000100)]
    public void Job(Action<RW<C0>, R<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00000100)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000100)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00000100)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000011)]
    public void Job(Action<RW<C0>, RW<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00000011)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000011)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00000011)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, R<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000010)]
    public void Job(Action<RW<C0>, RW<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00000010)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000010)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00000010)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, R<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000001)]
    public void Job(Action<RW<C0>, RW<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00000001)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000001)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00000001)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, RW<C2>, R<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000000)]
    public void Job(Action<RW<C0>, RW<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00010000_00000000)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000000)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00010000_00000000)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, RW<C2>, RW<C3>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3));
               }
           } while (join.Iterate());
       }
    }


}
public partial record Stream<C0, C1, C2, C3, C4>
{

    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00011111)]
    public void Job(Action<R<C0>, R<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00011111)]
    public void Job(Action<EntityRef, R<C0>, R<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00011111)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00011111)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00011110)]
    public void Job(Action<R<C0>, R<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00011110)]
    public void Job(Action<EntityRef, R<C0>, R<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00011110)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00011110)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00011101)]
    public void Job(Action<R<C0>, R<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00011101)]
    public void Job(Action<EntityRef, R<C0>, R<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00011101)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00011101)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00011100)]
    public void Job(Action<R<C0>, R<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00011100)]
    public void Job(Action<EntityRef, R<C0>, R<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00011100)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00011100)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00011011)]
    public void Job(Action<R<C0>, R<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00011011)]
    public void Job(Action<EntityRef, R<C0>, R<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00011011)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00011011)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00011010)]
    public void Job(Action<R<C0>, R<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00011010)]
    public void Job(Action<EntityRef, R<C0>, R<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00011010)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00011010)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00011001)]
    public void Job(Action<R<C0>, R<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00011001)]
    public void Job(Action<EntityRef, R<C0>, R<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00011001)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00011001)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00011000)]
    public void Job(Action<R<C0>, R<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00011000)]
    public void Job(Action<EntityRef, R<C0>, R<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00011000)]
    public void Job<U>(U uniform, Action<U, R<C0>, R<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00011000)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, R<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00010111)]
    public void Job(Action<R<C0>, RW<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00010111)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00010111)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00010111)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00010110)]
    public void Job(Action<R<C0>, RW<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00010110)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00010110)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00010110)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00010101)]
    public void Job(Action<R<C0>, RW<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00010101)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00010101)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00010101)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00010100)]
    public void Job(Action<R<C0>, RW<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00010100)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00010100)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00010100)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00010011)]
    public void Job(Action<R<C0>, RW<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00010011)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00010011)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00010011)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00010010)]
    public void Job(Action<R<C0>, RW<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00010010)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00010010)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00010010)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00010001)]
    public void Job(Action<R<C0>, RW<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00010001)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00010001)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00010001)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00010000)]
    public void Job(Action<R<C0>, RW<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00010000)]
    public void Job(Action<EntityRef, R<C0>, RW<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00010000)]
    public void Job<U>(U uniform, Action<U, R<C0>, RW<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00010000)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>, RW<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001111)]
    public void Job(Action<RW<C0>, R<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00001111)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001111)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00001111)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001110)]
    public void Job(Action<RW<C0>, R<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00001110)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001110)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00001110)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001101)]
    public void Job(Action<RW<C0>, R<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00001101)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001101)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00001101)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001100)]
    public void Job(Action<RW<C0>, R<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00001100)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001100)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00001100)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001011)]
    public void Job(Action<RW<C0>, R<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00001011)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001011)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00001011)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001010)]
    public void Job(Action<RW<C0>, R<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00001010)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001010)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00001010)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001001)]
    public void Job(Action<RW<C0>, R<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00001001)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001001)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00001001)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00001000)]
    public void Job(Action<RW<C0>, R<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00001000)]
    public void Job(Action<EntityRef, RW<C0>, R<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00001000)]
    public void Job<U>(U uniform, Action<U, RW<C0>, R<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00001000)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, R<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i]), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000111)]
    public void Job(Action<RW<C0>, RW<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00000111)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000111)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00000111)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, R<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000110)]
    public void Job(Action<RW<C0>, RW<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00000110)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000110)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00000110)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, R<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000101)]
    public void Job(Action<RW<C0>, RW<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00000101)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000101)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00000101)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, R<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000100)]
    public void Job(Action<RW<C0>, RW<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00000100)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000100)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00000100)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, R<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i]), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000011)]
    public void Job(Action<RW<C0>, RW<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00000011)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000011)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00000011)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, RW<C2>, R<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000010)]
    public void Job(Action<RW<C0>, RW<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00000010)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000010)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00000010)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, RW<C2>, R<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i]), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000001)]
    public void Job(Action<RW<C0>, RW<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00000001)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000001)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00000001)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, RW<C2>, RW<C3>, R<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000000)]
    public void Job(Action<RW<C0>, RW<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00100000_00000000)]
    public void Job(Action<EntityRef, RW<C0>, RW<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000000)]
    public void Job<U>(U uniform, Action<U, RW<C0>, RW<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00100000_00000000)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>, RW<C1>, RW<C2>, RW<C3>, RW<C4>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0, C1, C2, C3, C4>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var (s0, s1, s2, s3, s4) = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;job.Memory1 = s1.AsMemory(start, length);job.Type1 = s1.Expression;job.Memory2 = s2.AsMemory(start, length);job.Type2 = s2.Expression;job.Memory3 = s3.AsMemory(start, length);job.Type3 = s3.Expression;job.Memory4 = s4.AsMemory(start, length);job.Type4 = s4.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0), new(ref span1[i], in entity, in type1), new(ref span2[i], in entity, in type2), new(ref span3[i], in entity, in type3), new(ref span4[i], in entity, in type4));
               }
           } while (join.Iterate());
       }
    }


}
