// <auto-generated/>
using System.Runtime.CompilerServices;
using fennecs.pools;
using fennecs.storage;

// ReSharper disable InconsistentNaming

namespace fennecs;
public partial record Stream<C0>
{

    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000001)]
    public void Job(Action<R<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00000010_00000001)]
    public void Job(Action<EntityRef, R<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000001)]
    public void Job<U>(U uniform, Action<U, R<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00000010_00000001)]
    public void Job<U>(U uniform, Action<EntityRef, U, R<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i]));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:Job"]'/>
    [OverloadResolutionPriority(0b_00000000_00000000)]
    public void Job(Action<RW<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(ref span0[i], in entity, in type0));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobE"]'/>
    [OverloadResolutionPriority(0b_00000010_00000000)]
    public void Job(Action<EntityRef, RW<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), new(ref span0[i], in entity, in type0));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobU"]'/>
    [OverloadResolutionPriority(0b_00000000_00000000)]
    public void Job<U>(U uniform, Action<U, RW<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(uniform, new(ref span0[i], in entity, in type0));
               }
           } while (join.Iterate());
       }
    }



    /// <include file='../XMLdoc.xml' path='members/member[@name="T:JobEU"]'/>
    [OverloadResolutionPriority(0b_00000010_00000000)]
    public void Job<U>(U uniform, Action<EntityRef, U, RW<C0>> action)
    {
       using var worldLock = World.Lock();

       foreach (var table in Filtered)
       {
           var count = table.Count;
           using var join = table.CrossJoin<C0>(_streamTypes.AsSpan());
           if (join.Empty) continue;
           do
           {
               var s0 = join.Select;
               job.World = table.World;job.MemoryE = table.GetStorage<Identity>().AsReadOnlyMemory(start, length);job.Memory0 = s0.AsMemory(start, length);job.Type0 = s0.Expression;
               for (var i = 0; i < count; i++)
               {
                   var entity = table[i];
                   action(new(in entity), uniform, new(ref span0[i], in entity, in type0));
               }
           } while (join.Iterate());
       }
    }


}
