// <auto-generated/>
using System.Runtime.CompilerServices;
using fennecs.pools;
using fennecs.storage;

namespace fennecs;

#pragma warning disable CS0414 // Field is assigned but its value is never used
// ReSharper disable file IdentifierTypo

internal record JobRR<C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal ReadOnlyMemory<C0> Memory0 = null!;
    internal ReadOnlyMemory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;




    public Action<R<C0>, R<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(new(in span0[i]), new(in span1[i]));
        }
        CountDown.Signal();
    }
}

internal record JobERR<C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal ReadOnlyMemory<C0> Memory0 = null!;
    internal ReadOnlyMemory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;




    public Action<EntityRef, R<C0>, R<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(new(in entity), new(in span0[i]), new(in span1[i]));
        }
        CountDown.Signal();
    }
}

internal record JobURR<U, C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal ReadOnlyMemory<C0> Memory0 = null!;
    internal ReadOnlyMemory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;


    internal U Uniform = default!;

    public Action<U, R<C0>, R<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(Uniform, new(in span0[i]), new(in span1[i]));
        }
        CountDown.Signal();
    }
}

internal record JobEURR<U, C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal ReadOnlyMemory<C0> Memory0 = null!;
    internal ReadOnlyMemory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;


    internal U Uniform = default!;

    public Action<EntityRef, U, R<C0>, R<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(new(in entity), Uniform, new(in span0[i]), new(in span1[i]));
        }
        CountDown.Signal();
    }
}

internal record JobRW<C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal ReadOnlyMemory<C0> Memory0 = null!;
    internal Memory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;




    public Action<R<C0>, RW<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(new(in span0[i]), new(ref span1[i], in entity, in Type1));
        }
        CountDown.Signal();
    }
}

internal record JobERW<C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal ReadOnlyMemory<C0> Memory0 = null!;
    internal Memory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;




    public Action<EntityRef, R<C0>, RW<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(new(in entity), new(in span0[i]), new(ref span1[i], in entity, in Type1));
        }
        CountDown.Signal();
    }
}

internal record JobURW<U, C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal ReadOnlyMemory<C0> Memory0 = null!;
    internal Memory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;


    internal U Uniform = default!;

    public Action<U, R<C0>, RW<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(Uniform, new(in span0[i]), new(ref span1[i], in entity, in Type1));
        }
        CountDown.Signal();
    }
}

internal record JobEURW<U, C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal ReadOnlyMemory<C0> Memory0 = null!;
    internal Memory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;


    internal U Uniform = default!;

    public Action<EntityRef, U, R<C0>, RW<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(new(in entity), Uniform, new(in span0[i]), new(ref span1[i], in entity, in Type1));
        }
        CountDown.Signal();
    }
}

internal record JobWR<C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal Memory<C0> Memory0 = null!;
    internal ReadOnlyMemory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;




    public Action<RW<C0>, R<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(new(ref span0[i], in entity, in Type0), new(in span1[i]));
        }
        CountDown.Signal();
    }
}

internal record JobEWR<C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal Memory<C0> Memory0 = null!;
    internal ReadOnlyMemory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;




    public Action<EntityRef, RW<C0>, R<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(new(in entity), new(ref span0[i], in entity, in Type0), new(in span1[i]));
        }
        CountDown.Signal();
    }
}

internal record JobUWR<U, C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal Memory<C0> Memory0 = null!;
    internal ReadOnlyMemory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;


    internal U Uniform = default!;

    public Action<U, RW<C0>, R<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(Uniform, new(ref span0[i], in entity, in Type0), new(in span1[i]));
        }
        CountDown.Signal();
    }
}

internal record JobEUWR<U, C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal Memory<C0> Memory0 = null!;
    internal ReadOnlyMemory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;


    internal U Uniform = default!;

    public Action<EntityRef, U, RW<C0>, R<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(new(in entity), Uniform, new(ref span0[i], in entity, in Type0), new(in span1[i]));
        }
        CountDown.Signal();
    }
}

internal record JobWW<C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal Memory<C0> Memory0 = null!;
    internal Memory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;




    public Action<RW<C0>, RW<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(new(ref span0[i], in entity, in Type0), new(ref span1[i], in entity, in Type1));
        }
        CountDown.Signal();
    }
}

internal record JobEWW<C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal Memory<C0> Memory0 = null!;
    internal Memory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;




    public Action<EntityRef, RW<C0>, RW<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(new(in entity), new(ref span0[i], in entity, in Type0), new(ref span1[i], in entity, in Type1));
        }
        CountDown.Signal();
    }
}

internal record JobUWW<U, C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal Memory<C0> Memory0 = null!;
    internal Memory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;


    internal U Uniform = default!;

    public Action<U, RW<C0>, RW<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(Uniform, new(ref span0[i], in entity, in Type0), new(ref span1[i], in entity, in Type1));
        }
        CountDown.Signal();
    }
}

internal record JobEUWW<U, C0, C1> : IThreadPoolWorkItem
    where C0 : notnull where C1 : notnull
{
    public ReadOnlyMemory<Identity> MemoryE = null!;
    public World World = null!;

    internal Memory<C0> Memory0 = null!;
    internal Memory<C1> Memory1 = null!;


    internal TypeExpression Type0 = default;
    internal TypeExpression Type1 = default;


    internal U Uniform = default!;

    public Action<EntityRef, U, RW<C0>, RW<C1>> Action = null!;
    public CountdownEvent CountDown = null!;
    public void Execute()
    {
        var identities = MemoryE.Span;
        var span0 = Memory0.Span; var span1 = Memory1.Span;

        var count = identities.Length;
        for (var i = 0; i < count; i++)
        {
            var entity = new Entity(World, identities[i]);
            Action(new(in entity), Uniform, new(ref span0[i], in entity, in Type0), new(ref span1[i], in entity, in Type1));
        }
        CountDown.Signal();
    }
}

